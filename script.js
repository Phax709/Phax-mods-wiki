const translations = {
  fr: {
    accueil: "Accueil",
    language: "Langue",
    news_title: "Nouveautés",
    site_title: "Wiki des Mods de Phax709",
    acatar: "Acatar",
    chaosium: "Chaosium",
    home_acatar_desc: "Un mod qui facilite les nouveaux joueurs dans Minecraft ainsi pour les joueurs avec plus d'expérience des fonctionnalités nouvelles.",
    home_chaosium_desc: "Un mod fait pour les joueurs très expérimentés et qui veulent du challenge et de la difficulté ! D'où sont nom !",
    patchnotes: "Patch Notes",
    settings: "Paramètres",
    credits: "Crédits",
    back: "Retour",
    theme_label: "Thème :",
    font_label: "Taille du texte :",
    dark: "Sombre",
    light: "Clair",
    blue: "Bleu",
    font_normal: "Normale",
    font_large: "Grand",
    font_xlarge: "Très grand",
    search_placeholder: "Rechercher…",
    layout_label: "Affichage",
    layout_2x3: "2 colonnes × 3 rangées",
    layout_3x2: "3 colonnes × 2 rangées",
    home_welcome_title: "Bienvenue",
    home_welcome_p1_a: "Bienvenue sur le wiki des mods Minecraft créé par",
    home_welcome_p2: "Sélectionnez un mod dans le menu en haut pour en savoir plus !",
    all_mc_versions: "Toutes les versions Minecraft",
    sort_new_to_old: "Plus récent → plus ancien",
    sort_old_to_new: "Plus ancien → plus récent",
    tout: "Tout",
    blocs: "Blocs",
    items: "Objets",
    mobs: "Mobs",
    nature: "Nature",
    structure: "Structures",
    minerai: "Minerais",
    craft: "Craft / Recette", //à choisir mais je peux aussi mettre Recette
    patch_acatar: "Patchnotes Acatar",
    patch_chaosium: "Patchnotes Chaosium",
    patch_history: "Historique des mises à jour",
    build_label: "Type",
    build_all: "Tous",
    build_release: "Release",
    build_beta: "Beta",
    build_alpha: "Alpha",
    prochaine_maj: "Prochaine mise à jour",
    pourcentage_complete: "{percent}% complété",
    next_update: "Prochaine mise à jour",
    status: "Statut",
    mod_status_title: "Statut du mod",
    progress_label: "Progression",
    planned_features: "Fonctionnalités prévues",
    planned_update: "Mise à jour prévue pour le ",
    help_title: "Nous aider",
    help_desc: "Signalez un bug ou proposez une idée pour améliorer les mods.",
    report_bug: "Signaler un bug",
    suggest_idea: "Proposer une suggestion",
    satisfaction_survey: "Enquête de satisfaction",
    langue_fr: "Français",
    langue_en: "English",
    credits_title: "Crédits",
    credits_intro: "Cette page liste les droits d’auteur et les attributions des éléments utilisés dans ce wiki.",
    assets_mojang_title: "Attribution — Mojang / Minecraft",
    assets_mojang_text: "Minecraft est une marque déposée de Mojang AB. Certaines textures (ex. lingots, blocs) utilisées sur ce site et/ou dans les mods sont des dérivés des textures de Minecraft (recolorations/variantes). Ce site et ces mods ne sont ni affiliés, ni approuvés par Mojang AB. Aucun fichier de jeu original n’est redistribué. ⚠️ Cette attribution s’applique à toutes les images du wiki qui intègrent des textures dérivées ou historiques de Minecraft, y compris les captures de recettes, les aperçus de blocs et autres illustrations. Ces visuels sont présentés à titre d’exemple uniquement.",
    your_textures_title: "Textures & images originales",
    your_textures_text: "Certaines textures et images de ce wiki et/ou de mes mods sont des créations originales de Phax709. Toute réutilisation, redistribution ou intégration dans un autre projet (site, mod, resource pack, vidéo, etc.) nécessite mon autorisation préalable. Merci de me contacter sur Discord (lien en bas de page) pour obtenir l’accord.",
    third_party_title: "Éléments tiers",
    third_party_discord: "Logo Discord © Discord",
    site_stack_title: "Stack du site",
    site_stack_host: "Hébergement : GitHub Pages",
    site_stack_code: "Code front : HTML / CSS / JavaScript (vanilla) / JSON",
    credits_contact: "Attribution manquante ou question d’utilisation ? Contactez-moi sur le serveur Discord (lien en bas de page).",
    mods_credits_title: "Crédits liés aux mods",
    mods_credits_text: "Sauf mention contraire, le code des mods, les assets non issus de Minecraft (textures, logos, images) et la documentation sont créés par Phax709. Les éléments dérivés de Minecraft appartiennent à Mojang AB (voir l’attribution ci-dessus).",
    license_title: "Licence",
    license_intro: "Sauf mention contraire, le contenu de ce site (texte, mises en page, images originales) est sous licence CC BY-NC-ND 4.0 — © 2025 Phax709.",
    license_point_1: "Redistribution non commerciale autorisée avec crédit “Phax709” et lien vers ce site.",
    license_point_2: "Aucune modification ni re-upload des fichiers.",
    license_point_3: "Vidéos YouTube / streams Twitch monétisés autorisés : crédit + lien, sans héberger les fichiers.",
    license_point_4: "Modpacks / rehosts interdits sans autorisation écrite."

  },
  en: {
    accueil: "Home",
    language: "Language",
    news_title: "What's new",
    site_title: "Phax709 Mods Wiki",
    acatar: "Acatar",
    chaosium: "Chaosium",
    home_acatar_desc: "A mod that facilitates new players in Minecraft as well as for players with more experience of the new features.",
    home_chaosium_desc: "A mod made for very experienced players who want challenge and difficulty! Hence the name!",
    patchnotes: "Patch Notes",
    settings: "Settings",
    credits: "Credits",
    back: "Back",
    theme_label: "Theme:",
    font_label: "Text size:",
    dark: "Dark",
    light: "Light",
    blue: "Blue",
    font_normal: "Normal",
    font_large: "Large",
    font_xlarge: "Very large",
    search_placeholder: "Search…",
    layout_label: "Layout",
    layout_2x3: "2 columns × 3 rows",
    layout_3x2: "3 columns × 2 rows",
    home_welcome_title: "Welcome",
    home_welcome_p1_a: "Welcome to the wiki for Minecraft mods created by",
    home_welcome_p2: "Pick a mod from the top menu to learn more!",
    all_mc_versions: "All Minecraft versions",
    sort_new_to_old: "Newest → oldest",
    sort_old_to_new: "Oldest → newest",
    tout: "All",
    blocs: "Blocks",
    items: "Items",
    mobs: "Mobs",
    nature: "Nature",
    structure: "Structures",
    minerai: "Ores",
    craft: "Craft / Recipe", //à choisir mais je peux aussi mettre Recette
    patch_acatar: "Acatar Patch Notes",
    patch_chaosium: "Chaosium Patch Notes",
    patch_history: "Patch History",
    build_label: "Type",
    build_all: "All",
    build_release: "Release",
    build_beta: "Beta",
    build_alpha: "Alpha",
    prochaine_maj: "Next Update",
    pourcentage_complete: "{percent}% complete",
    next_update: "Next Update",
    status: "Status",
    mod_status_title: "Mod Status",
    progress_label: "Progress",
    planned_features: "Planned features",
    planned_update: "Update planned for ",
    help_title: "Help us",
    help_desc: "Report a bug or suggest an idea to improve the mods.",
    report_bug: "Report a bug",
    suggest_idea: "Suggest an idea",
    satisfaction_survey: "Satisfaction survey",
    langue_fr: "French",
    langue_en: "English",
    credits_title: "Credits",
    credits_intro: "This page lists copyrights and attributions for the assets used on this wiki.",
    assets_mojang_title: "Attribution — Mojang / Minecraft",
    assets_mojang_text: "Minecraft is a trademark of Mojang AB. Some textures (e.g., ingots, blocks) used on this site and/or in the mods are derived from Minecraft textures (recolorations/variants). This site and these mods are neither affiliated with nor approved by Mojang AB. No original game files are redistributed. ⚠️ This attribution applies to all images on the wiki that include derived or legacy Minecraft textures, including recipe screenshots, block previews, and other illustrations. Such visuals are provided for illustrative purposes only.",
    your_textures_title: "Original textures & images",
    your_textures_text: "Some textures and images on this wiki and/or in my mods are original creations by Phax709. Any reuse, redistribution, or inclusion in another project (website, mod, resource pack, video, etc.) requires my prior permission. Please contact me on Discord (link in the footer) to request approval.",
    third_party_title: "Third-party elements",
    third_party_discord: "Discord logo © Discord",
    site_stack_title: "Site stack",
    site_stack_host: "Hosting: GitHub Pages",
    site_stack_code: "Frontend: HTML / CSS / JavaScript (vanilla) / JSON",
    credits_contact: "Missing attribution or usage question? Ping me on the Discord server (link in the footer).",
    mods_credits_title: "Mod credits",
    mods_credits_text: "Unless stated otherwise, the mod code, non-Minecraft assets (textures, logos, images), and documentation are created by Phax709. Derivative elements of Minecraft remain the property of Mojang AB (see attribution above).",
    license_title: "License",
    license_intro: "Unless stated otherwise, the content of this site (text, layouts, original images) is licensed under CC BY-NC-ND 4.0 — © 2025 Phax709.",
    license_point_1: "Non-commercial redistribution allowed with credit “Phax709” and a link to this site.",
    license_point_2: "No file modifications or re-uploads.",
    license_point_3: "Monetized YouTube/Twitch allowed for showcasing: credit + link, no file hosting.",
    license_point_4: "Modpacks / rehosts forbidden without written permission."

  }
};

/********************
 * CONSTANTES & ÉTAT
 ********************/
const ETAT = {
  langue: localStorage.getItem('siteLanguage') || 'fr',
  theme: localStorage.getItem('siteTheme') || 'theme-clair', // "theme-clair" | "theme-sombre"
  fontSize: localStorage.getItem('siteFont') || 'font-normal', // "font-normal" | "font-grand" | "font-tres-grand"
};

const SELECTEURS = {
  // Header
  settingsMenu: '#settingsMenu',
  settingsToggle: '#settingsToggle',
  settingsPanel: '#settingsPanel',
  langSelector: '.lang-selector',
  langBtn: '#currentLangBtn',
  langDropdown: '#langDropdown',
  langFlag: '#currentLangFlag',

  // Pages & navigation
  page: '.page',
  navLiens: '.bandeau nav a',

  // Patchnotes
  patchList: '#patchnotes .patch-list',

  // Cartes
  mod1Grid: '#mod1 .cards-grid',
  mod2Grid: '#mod2 .cards-grid',
};

const CARD_SOURCES = {
  mod1: 'cards/cards_mod1.json',
  mod2: 'cards/cards_mod2.json',
};

const _cache = {
  cartes: {},
  patchnotes: null,
};


/********************
 * OUTILS DOM
 ********************/
const $ = (sel, root = document) => root.querySelector(sel);
const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

function show(el) { if (el) el.style.display = 'block'; }
function hide(el) { if (el) el.style.display = 'none'; }
function addClass(el, c) { if (el) el.classList.add(c); }
function remClass(el, c) { if (el) el.classList.remove(c); }
function hasClass(el, c) { return !!(el && el.classList.contains(c)); }
// --- URL helper (hash) : écrit p / type / card / q...
function setParams(obj, replace = false) {
  const sp = new URLSearchParams((location.hash || '').slice(1));
  Object.entries(obj || {}).forEach(([k, v]) => {
    if (v == null || v === '') sp.delete(k); else sp.set(k, v);
  });
  const next = '#' + sp.toString();
  if (replace) history.replaceState(null, '', next);
  else         history.pushState(null, '', next);
}

function syncFilterActive(modId){
  const page  = document.getElementById(modId);
  if (!page) return;
  const type  = localStorage.getItem(`${modId}:lastType`) || 'all';
  const group = page.querySelector('.side-buttons');
  if (!group) return;

  group.querySelectorAll('.card-btn').forEach(b => b.classList.remove('active'));
  (group.querySelector(`.card-btn[data-type="${type}"]`)
    || group.querySelector(`.card-btn[data-type="all"]`)
  )?.classList.add('active');
}

function markFilterActive(modId, type){
  const page  = document.getElementById(modId);
  if (!page) return;
  const group = page.querySelector('.side-buttons');
  if (!group) return;

  // clé finale (par défaut 'all')
  const key = (type && type !== 'all') ? type : 'all';

  // reset
  group.querySelectorAll('.card-btn').forEach(btn => {
    btn.classList.remove('active');
    btn.removeAttribute('aria-pressed');
  });

  // cible
  const target =
    group.querySelector(`.card-btn[data-type="${key}"]`)
    || group.querySelector(`.card-btn[data-type="all"]`);

  if (target){
    target.classList.add('active');
    target.setAttribute('aria-pressed', 'true');
  }
}

function getCardsForPage(page){
  if (!page) return [];
  if (!page._cards) {
    const grid = page.querySelector('.cards-grid');
    page._cards = grid ? Array.from(grid.querySelectorAll('.small-card')) : [];
  }
  return page._cards;
}

function debounce(fn, delay=120){
  let to; return (...args)=>{ clearTimeout(to); to=setTimeout(()=>fn(...args), delay); };
}


/********************
 * I18N (simple)
 ********************/
/********************
 * I18N — applique les traductions SANS casser les menus
 ********************/
function setPageTitle(lang) {
  const wanted = (translations?.[lang]?.site_title) || translations.fr.site_title || '';

  // cible prioritairement <title id="siteTitle">
  let titleEl = document.getElementById('siteTitle') || document.querySelector('head > title');
  if (!titleEl) {
    titleEl = document.createElement('title');
    titleEl.id = 'siteTitle';
    document.head.appendChild(titleEl);
  }
  titleEl.textContent = wanted;

  // synchronise l’API document.title (barre d’onglet)
  document.title = wanted;
}

function applyTranslations(lang) {
  const dict = (translations && translations[lang]) ? translations[lang] : translations.fr;

  // Remplace uniquement le texte des éléments marqués data-translate
  document.querySelectorAll('[data-translate]').forEach(el => {
    const key = el.getAttribute('data-translate')?.trim();
    if (!key) return;

    let txt = dict[key];
    if (txt == null) return;

    // Placeholder {percent} optionnel si l'élément donne une valeur
    const pct = el.getAttribute('data-percent');
    if (pct) txt = txt.replace('{percent}', pct);

    // IMPORTANT : n’écrase pas la structure (pas d’innerHTML ici)
    el.textContent = txt;
  });

  // (Optionnel) Met à jour le libellé des options de langue si tu as un span dédié
  // Exemple HTML recommandé :
  // <button class="lang-option" data-lang="fr"><img ...><span class="lbl"></span></button>
  const frLbl = document.querySelector('.lang-option[data-lang="fr"] .lbl');
  if (frLbl) frLbl.textContent = dict.langue_fr;
  const enLbl = document.querySelector('.lang-option[data-lang="en"] .lbl');
  if (enLbl) enLbl.textContent = dict.langue_en;

  document.querySelectorAll('[data-translate-placeholder]').forEach(el=>{
  const k = el.getAttribute('data-translate-placeholder'); 
  if (translations[lang]?.[k]) el.placeholder = translations[lang][k];
});
document.querySelectorAll('[data-translate-title]').forEach(el=>{
  const k = el.getAttribute('data-translate-title'); 
  if (translations[lang]?.[k]) el.title = translations[lang][k];
});

}

function setLanguage(lang) {
  const chosen = lang || 'fr';
  ETAT.langue = chosen;
  localStorage.setItem('siteLanguage', chosen);

  document.documentElement.setAttribute('lang', chosen);

  const flag = document.querySelector('#currentLangFlag');
  if (flag) flag.src = (chosen === 'en') ? 'images/flag-gb.png' : 'images/flag-fr.png';

  applyTranslations(chosen);
  setPageTitle(chosen); // <= ajoute cette ligne

  if (document.getElementById('patchnotes')?.style.display !== 'none') renderPatchList();
  if (document.getElementById('mod1')?.style.display !== 'none') ensureCards('mod1');
  if (document.getElementById('mod2')?.style.display !== 'none') ensureCards('mod2');

  const st1 = document.querySelector('#mod1 .update-panel');
  if (st1 && st1.style.display !== 'none') showStatus('mod1', true);
  const st2 = document.querySelector('#mod2 .update-panel');
  if (st2 && st2.style.display !== 'none') showStatus('mod2', true);
  if (window.__refreshHomeChips) window.__refreshHomeChips();
  ensureStatusTitle();
  if (window.__refreshNewsLang) window.__refreshNewsLang();
}



/********************
 * THÈME & TAILLE DE POLICE
 ********************/
function appliquerThemeEtPolice() {
  document.body.classList.remove('theme-clair', 'theme-sombre', 'theme-bleu', 'font-normal', 'font-grand', 'font-tres-grand');
  document.body.classList.add(ETAT.theme, ETAT.fontSize);
}

function initThemeEtPolice() {
  // Applique l’état sauvegardé
  appliquerThemeEtPolice();

  // Boutons (optionnels si présents dans ton HTML)
  const btnSombre = document.getElementById('themeSombre');
  const btnClair = document.getElementById('themeClair');
  const btnBleu = document.getElementById('themeBleu');
  const fontNormal = document.getElementById('fontNormal');
  const fontGrand = document.getElementById('fontGrand');
  const fontTresGrand = document.getElementById('fontTresGrand');

  if (btnSombre) btnSombre.addEventListener('click', () => {
    ETAT.theme = 'theme-sombre';
    localStorage.setItem('siteTheme', ETAT.theme);
    appliquerThemeEtPolice();
  });
  if (btnClair) btnClair.addEventListener('click', () => {
    ETAT.theme = 'theme-clair';
    localStorage.setItem('siteTheme', ETAT.theme);
    appliquerThemeEtPolice();
  });
  if (btnBleu) btnBleu.addEventListener('click', () => {
    ETAT.theme = 'theme-bleu';
    localStorage.setItem('siteTheme', ETAT.theme);
    appliquerThemeEtPolice();
  });


  if (fontNormal) fontNormal.addEventListener('click', () => {
    ETAT.fontSize = 'font-normal';
    localStorage.setItem('siteFont', ETAT.fontSize);
    appliquerThemeEtPolice();
  });
  if (fontGrand) fontGrand.addEventListener('click', () => {
    ETAT.fontSize = 'font-grand';
    localStorage.setItem('siteFont', ETAT.fontSize);
    appliquerThemeEtPolice();
  });
  if (fontTresGrand) fontTresGrand.addEventListener('click', () => {
    ETAT.fontSize = 'font-tres-grand';
    localStorage.setItem('siteFont', ETAT.fontSize);
    appliquerThemeEtPolice();
  });
}


/********************
 * MENU LANGUE
 ********************/
function initMenuLangue() {
  const langSelector = $(SELECTEURS.langSelector);
  const langBtn      = $(SELECTEURS.langBtn);
  const dropdown     = $(SELECTEURS.langDropdown);

  if (!langSelector || !langBtn || !dropdown) return;

  // Drapeau au chargement
  setLanguage(ETAT.langue);

  // Un SEUL handler pour ouvrir/fermer (état contrôlé)
  langBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    // fermer paramètres avant
    remClass($(SELECTEURS.settingsMenu), 'open');
    // toggle explicite
    if (hasClass(langSelector, 'open')) remClass(langSelector, 'open'); else addClass(langSelector, 'open');
  });

  // Choix langue
  dropdown.querySelectorAll('.lang-option').forEach(opt => {
    opt.addEventListener('click', (e) => {
      e.stopPropagation();
      const lang = opt.getAttribute('data-lang') || 'fr';
      setLanguage(lang);
      remClass(langSelector, 'open');
    });
  });

  // Empêche la fermeture immédiate si clic à l’intérieur
  langSelector.addEventListener('click', (e) => e.stopPropagation());
}


/********************
 * MENU PARAMÈTRES (⚙)
 ********************/
function initMenuParametres() {
  const settingsMenu   = $(SELECTEURS.settingsMenu);
  const settingsToggle = $(SELECTEURS.settingsToggle);
  const langSelector   = $(SELECTEURS.langSelector);

  if (!settingsMenu || !settingsToggle) return;

  settingsToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    // Fermer langue avant
    remClass(langSelector, 'open');
    // Toggle contrôlé
    if (hasClass(settingsMenu, 'open')) remClass(settingsMenu, 'open'); else addClass(settingsMenu, 'open');
  });

  // Empêche fermeture sur clic interne
  settingsMenu.addEventListener('click', (e) => e.stopPropagation());

  // Clic ailleurs → tout fermer
  document.addEventListener('click', () => {
    remClass(langSelector, 'open');
    remClass(settingsMenu, 'open');
  });
}


/********************
 * NAVIGATION PAGES
 ********************/
function showPage(pageId) {
  // 1) masquer toutes les pages
  document.querySelectorAll('.page').forEach(p => p.style.display = 'none');

  // 2) afficher la page demandée
  const page = document.getElementById(pageId);
  if (page) page.style.display = 'block';

  // 3) nav actif (header + drawer mobile)
  document.querySelectorAll('.bandeau nav a').forEach(a => a.classList.remove('active'));
  const headerNavId = (pageId === 'credits') ? 'nav-accueil' : ('nav-' + pageId);
  document.getElementById(headerNavId)?.classList.add('active');

  document.querySelectorAll('#mobileDrawer .drawer-link').forEach(a => a.classList.remove('active'));
  document.querySelector(`#mobileDrawer .drawer-link[data-page="${pageId}"]`)?.classList.add('active');

  // 4) état mémorisé
  try { localStorage.setItem('lastPage', pageId); } catch {}

  // 5) éléments contextuels
  const grid   = page?.querySelector('.cards-grid');
  const list   = page?.querySelector('.patch-list');
  const detail = page?.querySelector('.card-detail');
  const status = page?.querySelector('.update-panel');
  if (status) status.style.display = 'none';
  if (detail) detail.style.display = 'none';

  // --- lecture des paramètres URL (ex: #p=mod1&type=minerai)
  const sp = new URLSearchParams((location.hash || '').slice(1));
  const urlType = sp.get('type'); // null, 'all' ou une catégorie

  // 6) pages de mods : charger au besoin + restaurer vue & filtre
  if (pageId === 'mod1' || pageId === 'mod2') {
    if (grid) grid.style.display = 'grid';
    if (pageId === 'mod1' && typeof ensureCards === 'function') ensureCards('mod1');
    if (pageId === 'mod2' && typeof ensureCards === 'function') ensureCards('mod2');

    const savedType = localStorage.getItem(`${pageId}:lastType`) || 'all';
    const lastView  = localStorage.getItem(`${pageId}:lastView`) || 'grid';

    // Priorité au filtre (URL ou mémorisé ≠ all) → on force la grille
    const effectiveType = (urlType !== null ? urlType : savedType);
    const forceGrid = (urlType !== null) || (effectiveType && effectiveType !== 'all');

    if (forceGrid) {
      try { localStorage.setItem(`${pageId}:lastView`, 'grid'); } catch {}
      if (typeof filterCategory === 'function') filterCategory(pageId, effectiveType || 'all');
      if (typeof markFilterActive === 'function') markFilterActive(pageId, effectiveType || 'all');
    } else if (lastView === 'status') {
      if (typeof showStatus === 'function') showStatus(pageId);
    } else {
      if (typeof filterCategory === 'function') filterCategory(pageId, savedType);
      if (typeof markFilterActive === 'function') markFilterActive(pageId, savedType);
    }
  }

  // 7) patch notes
  if (pageId === 'patchnotes') {
    if (list)   list.style.display = 'flex';
    if (detail) detail.style.display = 'none';
    if (typeof renderPatchList === 'function') renderPatchList();
  }

  // 8) accueil : barre de statuts
  const bar  = document.getElementById('home-status');
  const rail = document.getElementById('statusRail');
  if (bar)  bar.style.display  = (pageId === 'accueil' ? 'flex'  : 'none');
  if (rail) rail.style.display = (pageId === 'accueil' ? 'block' : 'none');
  if (pageId === 'accueil') {
    if (typeof ensureStatusTitle === 'function') ensureStatusTitle();
    if (window.__refreshHomeChips) window.__refreshHomeChips();
  }

  // 9) UX : remonter, titre, back-to-top
  window.scrollTo({ top: 0, behavior: 'smooth' });
  if (typeof setPageTitle === 'function') setPageTitle(ETAT.langue);
  if (typeof updateBackToTop === 'function') updateBackToTop(pageId);

  // 10) URL : p + filtre effectif (si ≠ all), sans empiler l’historique
  if (typeof setParams === 'function') {
    let t = undefined;
    try {
      const eff = (urlType !== null ? urlType : (localStorage.getItem(`${pageId}:lastType`) || 'all'));
      if (eff && eff !== 'all') t = eff;
    } catch {}
    setParams({ p: pageId, type: t, card: undefined }, true);
  }
}

/********************
 * FILTRE & RECHERCHE — version qui ferme Statut et ré-affiche la grille
 ********************/
function filterCategory(pageId, category) {
  const page   = document.getElementById(pageId);
  if (!page) return;

  const grid   = page.querySelector('.cards-grid');
  const list   = page.querySelector('.patch-list');
  const detail = page.querySelector('.card-detail');
  const status = page.querySelector('.update-panel');

  if (status) status.style.display = 'none';
  if (detail) detail.style.display = 'none';
  if (grid)   grid.style.display   = 'grid';
  if (list)   list.style.display   = 'flex';

  const key = (category && category !== 'all') ? category : 'all';

  // 🔸 On réutilise la NodeList mise en cache
  const cards = getCardsForPage(page);
  cards.forEach(card => {
    const show = (key === 'all') || card.classList.contains(key);
    // IMPORTANT : '' (pas 'block') pour laisser la grid gérer l’affichage
    card.style.display = show ? '' : 'none';
  });

  // État UI + mémorisation + URL (une seule fois)
  const group = page.querySelector('.side-buttons');
  if (group) {
    group.querySelectorAll('.card-btn').forEach(b => b.classList.remove('active'));
    (group.querySelector(`.card-btn[data-type="${key}"]`) ||
     group.querySelector(`.card-btn[data-type="all"]`))?.classList.add('active');
  }

  try {
    localStorage.setItem('lastPage', pageId);
    localStorage.setItem(`${pageId}:lastView`, 'grid');
    localStorage.setItem(`${pageId}:lastType`, key);
  } catch {}

  if (typeof setParams === 'function') {
    setParams({ p: pageId, type: (key !== 'all') ? key : undefined, card: undefined }, true);
  }
}

/********************
 * RECHERCHE (cartes) — corrige l’erreur "pageId" et force le retour à la grille
 ********************/
function searchCards(modId, query) {
  const page   = document.getElementById(modId);
  if (!page) return;

  const grid   = page.querySelector('.cards-grid');
  const detail = page.querySelector('.card-detail');
  const status = page.querySelector('.update-panel');

  if (status) status.style.display = 'none';
  if (detail) detail.style.display = 'none';
  if (grid)   grid.style.display   = 'grid';

  const qn = normalizeText(query || '');
  const cards = getCardsForPage(page);
  cards.forEach(card => {
    const t = normalizeText(card.querySelector('h4')?.textContent || '');
    const d = normalizeText(card.querySelector('p')?.textContent  || '');
    // 🔸 '' (pas 'block') pour ne pas casser la grille
    card.style.display = (!qn || t.includes(qn) || d.includes(qn)) ? '' : 'none';
  });
}

/********************
 * PATCHNOTES
 ********************/
async function loadPatchData() {
  if (_cache.patchnotes) return _cache.patchnotes;
  const res = await fetch('patchnotes.json' + `?t=${Date.now()}`, { cache: 'no-store' });
  if (!res.ok) throw new Error('HTTP ' + res.status);
  const data = await res.json();
  _cache.patchnotes = data;
  return data;
}

// État de la barre d’outils Patchnotes
let _patchToolbarInited = false;
let _patchMc     = "";      // filtre version MC
let _patchSearch = "";      // recherche texte
let _patchSort   = "desc";  // "asc" | "desc"
let _patchStage = 'all'; // "all" | "release" | "beta" | "alpha"

// Remplit le <select> des versions MC à partir du JSON
function populateVersionFilter(data) {
  const f = document.getElementById('patchVersionFilter');
  if (!f) return;
  const set = new Set((data || []).map(n => n.mc).filter(Boolean));
  const versions = Array.from(set).sort((a,b) => a.localeCompare(b, undefined, { numeric:true }));
  // ⬇️ change UNIQUEMENT cette ligne :
  f.innerHTML = `<option value="">${t('all_mc_versions')}</option>` +
                versions.map(v => `<option value="${v}">MC ${v}</option>`).join('');
}

// Branche la recherche, le filtre MC et le tri
function initPatchToolbar() {
  const q = document.getElementById('patchSearch');
  const f = document.getElementById('patchVersionFilter');
  const s = document.getElementById('patchDateSort');

  // Si la toolbar n'existe pas dans le HTML, on ne fait rien
  if (!q && !f && !s) { _patchToolbarInited = true; return; }

  if (q) q.addEventListener('input',  () => { _patchSearch = (q.value || '').trim().toLowerCase(); renderPatchList(); });
  if (f) f.addEventListener('change', () => { _patchMc = f.value; renderPatchList(); });
  if (s) s.addEventListener('change', () => { _patchSort = s.value || 'desc'; renderPatchList(); });

  _patchToolbarInited = true;
  const buildSel = document.getElementById('filter-build');
  if (buildSel) {
    buildSel.value = _patchStage;
    buildSel.addEventListener('change', () => {
      _patchStage = (buildSel.value || 'all').toLowerCase();
      renderPatchList();
    });
  }
}


function buildPatchEntryHTML(entry) {
  // Champs attendus (selon ton JSON) :
  // entry.title, entry.date, entry.mod ("acatar"|"chaosium"), entry.mc (version MC), entry.notes (array)
  const modClass = entry.mod ? entry.mod.toLowerCase() : 'acatar';
  const date = entry.date ? new Date(entry.date).toLocaleDateString(ETAT.langue === 'en' ? 'en-GB' : 'fr-FR') : '';
  const mcBadge = entry.mc ? `<span class="mc-badge">MC ${entry.mc}</span>` : '';
  const notes = Array.isArray(entry.notes) ? entry.notes.map(n => `<li>${n}</li>`).join('') : '';

  return `
    <div class="patch-entry ${modClass}">
      <div class="patch-meta">
        <h4>${entry.title || 'Patch'}</h4>
        <div class="patch-info">
          <span class="patch-date">${date}</span>
          ${mcBadge}
        </div>
      </div>
      <ul class="patch-notes">${notes}</ul>
    </div>
  `;
}

/********************
 * PATCHNOTES — liste (comme avant)
 ********************/
async function renderPatchList() {
  const list = document.querySelector('#patchnotes .patch-list');
  if (!list) return;

  const lang = localStorage.getItem('siteLanguage') || 'fr';
  const data = await loadPatchData(); // lit patchnotes.json

  // 1) Init toolbar au premier rendu
  if (!_patchToolbarInited) {
    populateVersionFilter(data);
    initPatchToolbar();
  }

  // ===== Helpers =====
  const getMc = (n) => {
    const raw = n.mc || n.minecraft_version || n.minecraftVersion || n.minecraft || n.mc_version || n.mcVersion || "";
    return raw ? String(raw).replace(/^MC\s*/i, "") : "";
  };

  const isBeta = (n) => !!(
    n.beta === true || n.is_beta === true ||
    /beta/i.test([n.channel, n.stage, n.tag, n.version, n.title].filter(Boolean).join(' '))
  );

  // "release" | "beta" | "alpha" (fallback: release)
  const getStage = (n) => {
    const s = (n.stage || '').toString().toLowerCase();
    if (s === 'release' || s === 'beta' || s === 'alpha') return s;
    const hay = [n.channel, n.tag, n.version, n.title].filter(Boolean).join(' ').toLowerCase();
    if (isBeta(n)) return 'beta';
    if (/\balpha\b/.test(hay)) return 'alpha';
    return 'release';
  };

  // 2) Catégorie active (menu gauche) : all | acatar | chaosium
  const activeBtn = document.querySelector('#patchnotes .side-buttons .card-btn.active');
  const cat = activeBtn ? (activeBtn.getAttribute('data-cat') || 'all') : 'all';

  // 3) Source + filtre catégorie via "mod"
  let notes = data.filter(n => (cat === 'all' ? true : (n.mod || '').toLowerCase() === cat));

  // 4) Filtre version Minecraft
  if (_patchMc) notes = notes.filter(n => getMc(n) === _patchMc);

  // 4bis) Filtre type de build (release/beta/alpha)
  const stageFilter = (typeof _patchStage !== 'undefined' ? _patchStage : 'all');
  if (stageFilter && stageFilter !== 'all') {
    notes = notes.filter(n => getStage(n) === stageFilter);
  }

  // 5) Recherche (titre + sections) — accent-insensible
  if (_patchSearch) {
    const qn = normalizeText(_patchSearch);
    notes = notes.filter(n => {
      const title = (lang === 'fr' ? (n.title_fr || n.title_en) : (n.title_en || n.title_fr)) || '';
      const secs  = (lang === 'fr' ? (n.sections_fr || []) : (n.sections_en || []));
      const hay   = normalizeText(title + ' ' + secs.map(s => [s.title, ...(s.items||[])] .flat().join(' ')).join(' '));
      return hay.includes(qn);
    });
  }


  // 6) Tri date (ISO yyyy-mm-dd)
  notes.sort((a,b) => {
    const da = a.date || '';
    const db = b.date || '';
    return (_patchSort === 'asc') ? da.localeCompare(db) : db.localeCompare(da);
  });

  // 7) Rendu : gauche = titre + badges, droite = date
  list.innerHTML = '';
  notes.forEach(n => {
    const modKey = (n.mod || '').toLowerCase();
    const modName = (modKey === 'chaosium')
      ? (translations?.[lang]?.chaosium || 'Chaosium')
      : (translations?.[lang]?.acatar   || 'Acatar');

    const title   = `${modName}${n.version ? ` - v${n.version}` : ''}`;
    const mc      = getMc(n);
    const stage   = getStage(n);

    const mcBadge    = mc    ? `<span class="pn-badge mc">MC ${mc}</span>` : '';
    const labelStage =
      stage === 'release' ? (translations?.[lang]?.build_release || 'Release') :
      stage === 'alpha'   ? (translations?.[lang]?.build_alpha   || 'Alpha')   :
                            (translations?.[lang]?.build_beta    || 'Beta');
    const stageBadge  = stage ? `<span class="pn-badge ${stage}">${labelStage}</span>` : '';

    const dateHtml = n.date ? `<span class="pe-date">${n.date}</span>` : '';

    const div = document.createElement('div');
    div.className = `patch-entry ${modKey}`;
    div.dataset.id = n.id;

    // pe-title (avec badges) + date à droite
    div.innerHTML = `
      <span class="pe-title"><strong>${title}</strong> ${mcBadge} ${stageBadge}</span>
      ${dateHtml}
    `;
    div.addEventListener('click', () => showPatchDetail(n.id));
    list.appendChild(div);
  });

  // 8) Assure la bonne vue
  const detail = document.querySelector('#patchnotes .card-detail');
  if (detail) detail.style.display = 'none';
  list.style.display = 'flex';
}

/********************
 * PATCHNOTES — détail & retour
 ********************/
// === DÉTAIL PATCHNOTE : titre + badges (MC + Beta)
async function showPatchDetail(patchId) {
  if (typeof hideBackToTop === 'function') hideBackToTop();
  const list    = document.querySelector('#patchnotes .patch-list');
  const detail  = document.querySelector('#patchnotes .card-detail');
  const content = detail?.querySelector('.detail-content');
  if (!list || !detail || !content) return;
  detail.setAttribute('data-current-patch-id', String(patchId));

  const lang = localStorage.getItem('siteLanguage') || 'fr';
  const data = await loadPatchData();
  const n = (data || []).find(x => String(x.id) === String(patchId));
  if (!n) return;
  try {
  detail.setAttribute('data-current-patch-id', String(patchId));
} catch {}

  // Helpers locaux (mêmes règles que la liste)
  const getMc = (n) => {
    const raw = n.mc || n.minecraft_version || n.minecraftVersion || n.minecraft || n.mc_version || n.mcVersion || "";
    return raw ? String(raw).replace(/^MC\s*/i, "") : "";
  };
  const isBeta = (n) => !!(
    n.beta === true || n.is_beta === true ||
    /beta/i.test([n.channel, n.stage, n.tag, n.version, n.title].filter(Boolean).join(' '))
  );
  const getStage = (n) => {
    const s = (n.stage || '').toString().toLowerCase();
    if (s === 'release' || s === 'beta' || s === 'alpha') return s;
    const hay = [n.channel, n.tag, n.version, n.title].filter(Boolean).join(' ').toLowerCase();
    if (isBeta(n)) return 'beta';
    if (/\balpha\b/.test(hay)) return 'alpha';
    return 'release';
  };

  // Libellés mod
  const modKey  = (n.mod || '').toLowerCase();
  const modName = modKey === 'chaosium'
    ? (translations?.[lang]?.chaosium || 'Chaosium')
    : (translations?.[lang]?.acatar   || 'Acatar');

  const title = `${modName}${n.version ? ` - v${n.version}` : ''}`;
  const dateHtml = n.date ? `<div class="patch-meta">${n.date}</div>` : '';

  // Badges
  const mc = getMc(n);
  const mcBadge = mc ? `<span class="pn-badge mc">MC ${mc}</span>` : '';

  const stage = getStage(n);
  const labelStage =
    stage === 'release' ? (translations?.[lang]?.build_release || 'Release') :
    stage === 'alpha'   ? (translations?.[lang]?.build_alpha   || 'Alpha')   :
                          (translations?.[lang]?.build_beta    || 'Beta');
  const stageBadge = stage ? `<span class="pn-badge ${stage}">${labelStage}</span>` : '';

  // Sections FR/EN
  const sections = (lang === 'en') ? (n.sections_en || []) : (n.sections_fr || []);
  const sectionsHTML = sections.map(sec => `
    <div class="patchnote-section">
      <h4 class="underline">${sec.title || ''}</h4>
      <ul>${(sec.items || []).map(li => `<li>${li}</li>`).join('')}</ul>
    </div>
  `).join('');

  // Liens optionnels
  const links = Array.isArray(n.links) ? n.links : [];
  const linksHTML = links.length ? `
    <div class="patch-links" style="margin-top:10px;">
      ${links.map(L => {
        const label = (lang === 'en' ? (L.label_en || L.label_fr) : (L.label_fr || L.label_en)) || 'Link';
        return `<a class="card-btn wiki" href="${L.url}" target="_blank" rel="noopener">${label}</a>`;
      }).join(' ')}
    </div>` : '';

  // Rendu
  content.innerHTML = `
  <div class="pn-head">
    <h3>${title}</h3>
    <div class="pn-badges">
      ${mcBadge}
      ${stageBadge}
    </div>
  </div>
  ${dateHtml}
  ${sectionsHTML}
  ${linksHTML}
`;

  // bascule list/détail
  list.style.display   = 'none';
  detail.style.display = 'block';
  // Rebranche le back-to-top sur la liste Patchnotes et réévalue l'état
  updateBackToTop('patchnotes');
  const listEl = document.querySelector('#patchnotes .patch-list');
  if (listEl) setTimeout(() => listEl.dispatchEvent(new Event('scroll')), 0);

  window.scrollTo({ top: 0, behavior: 'smooth' });
}

function showPatchList() {
  const list   = document.querySelector('#patchnotes .patch-list');
  const detail = document.querySelector('#patchnotes .card-detail');
  if (!list || !detail) return;
  detail.style.display = 'none';
  list.style.display = 'flex'; // ta liste est en flex dans le CSS “comme avant”
  // Ré-attache le back-to-top sur la liste Patchnotes et force l'état
  updateBackToTop('patchnotes');
  const listEl = document.querySelector('#patchnotes .patch-list');
  if (listEl) { requestAnimationFrame(() => listEl.dispatchEvent(new Event('scroll'))); }
}

/********************
 * DÉTAIL CARTES
 ********************/
function showCardDetail(modId, el) {
  if (typeof hideBackToTop === 'function') hideBackToTop();
  const page = document.getElementById(modId);
  if (!page) return;
  const liste = page.querySelector('.cards-grid');
  const vue   = page.querySelector('.card-detail');
  const zone  = page.querySelector('.detail-content');
  if (!liste || !vue || !zone) return;

  liste.style.display = 'none';
  vue.style.display   = 'block';
  zone.innerHTML      = el.getAttribute('data-description') || '';
  try { page.querySelector('.card-detail')?.setAttribute('data-current-card-id', el.getAttribute('data-id') || ''); } catch(_){}
}

// Conserver le filtre dans l'URL quand on ouvre une carte (pour que Retour garde la liste filtrée)
(function patchShowCardDetail(){
  if (window.__patchShowCardDetail) return;
  window.__patchShowCardDetail = true;

  const orig = window.showCardDetail;
  if (typeof orig !== 'function') return;

  window.showCardDetail = function(modId, el){
    const id = el?.getAttribute('data-id') || '';

    // filtre "source de vérité" = ce qu'on a mémorisé
    let type = 'all';
    try { type = localStorage.getItem(`${modId}:lastType`) || 'all'; } catch {}

    setParams({
      p: modId,
      card: id,
      type: (type && type !== 'all') ? type : undefined
    }, false); // PUSH (pour que le bouton Retour revienne d'abord ici)

    return orig.apply(this, arguments);
  };
})();

// Récupère la clé de filtre active pour une page de mod
function __getActiveFilter(modId){
  // 1) ce qu'on a mémorisé (source de vérité)
  try {
    const saved = localStorage.getItem(`${modId}:lastType`);
    if (saved) return saved;
  } catch {}

  // 2) bouton actif dans l'UI (secours)
  const btnActive = document.querySelector(`#${modId} .side-buttons .card-btn.active`);
  if (btnActive) return btnActive.getAttribute('data-type') || 'all';

  // 3) URL (secours)
  const sp = new URLSearchParams((location.hash || '').slice(1));
  return sp.get('type') || 'all';
}

function hideCardDetail(modId) {
  const page  = document.getElementById(modId);
  if (!page) return;

  const grid  = page.querySelector('.cards-grid');
  const view  = page.querySelector('.card-detail');

  if (grid) grid.style.display = 'grid';
  if (view) view.style.display = 'none';

  // Filtre mémorisé
  let type = 'all';
  try { type = localStorage.getItem(`${modId}:lastType`) || 'all'; } catch {}

  // Réapplique le filtre (ne pas forcer display:block — on laisse '' pour la grid)
  if (typeof filterCategory === 'function') filterCategory(modId, type);

  // URL : on enlève la carte, on garde le filtre si ≠ all (REPLACE)
  if (typeof setParams === 'function') {
    setParams({
      p: modId,
      card: undefined,
      type: (type && type !== 'all') ? type : undefined
    }, true);
  }

  // Back-to-top
  if (typeof updateBackToTop === 'function') updateBackToTop(modId);
  if (grid) requestAnimationFrame(() => grid.dispatchEvent(new Event('scroll')));

  filterCategory(modId, type);
  syncFilterActive(modId);
  markFilterActive(modId, type);
}

/********************
 * STATUT (status.json) — pour mod1 / mod2
 ********************/

// Petit helper de traduction (utilise ton objet "translations")
function t(key) {
  const lang = localStorage.getItem('siteLanguage') || 'fr';
  return (translations?.[lang]?.[key]) ?? key;
}

// --- Normalise une chaîne (minuscule, sans accents/diacritiques)
function normalizeText(s) {
  s = (s || '').toString().toLowerCase();
  try {
    // Navigateurs modernes
    return s.normalize('NFD').replace(/\p{Diacritic}+/gu, '');
  } catch (_) {
    // Fallback
    return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }
}

// Mappe ce qui vient de status.json vers une classe CSS connue
function normalizeStatus(s) {
  const t = (s || '').toLowerCase().trim();
  if (t === 'release') return 'stable'; // "release" = stable (classe verte)
  if (t === 'developpement' || t === 'en développement' || t === 'development' || t === 'in development')
    return 'dev';
  return t; // stable | beta | dev
}

// Libellé affiché (FR/EN) à partir de la valeur BRUTE du JSON
function statusLabel(raw, lang) {
  const t = (raw || '').toLowerCase().trim();
  if (t === 'release' || t === 'stable') return (lang === 'en') ? 'Stable' : 'Stable';
  if (t === 'beta')                         return (lang === 'en') ? 'Beta'   : 'Bêta';
  return (lang === 'en') ? 'In development' : 'En développement';
}

// ——— Statut (status.json) ———
let _lastStatusOpen = null;

// Récupère une valeur localisée depuis info[base]
// - supporte base_lang (ex: next_update_fr), ou objet { fr, en }, ou string simple
function pickLocalized(info, base, lang) {
  if (!info) return "";
  const direct = info[`${base}_${lang}`];
  if (typeof direct === 'string' && direct.trim()) return direct.trim();

  const node = info[base];
  if (node && typeof node === 'object') {
    const v = node[lang];
    if (typeof v === 'string' && v.trim()) return v.trim();
  }
  if (typeof node === 'string' && node.trim()) return node.trim();
  return "";
}

async function showStatus(modId) {
  const panel = document.getElementById(`status-${modId}`) || document.querySelector(`#${modId} .update-panel`);
  if (!panel) return;

  const grid   = document.querySelector(`#${modId} .cards-grid`);
  const detail = document.querySelector(`#${modId} .card-detail`);
  if (grid)   grid.style.display = 'none';
  if (detail) detail.style.display = 'none';
  panel.style.border = 'none';

  if (location.protocol === 'file:') {
    panel.innerHTML = `
      <p style="color:#c62828">
        Le chargement du statut est bloqué en <code>file://</code>.<br>
        Lance ton site via un petit serveur local (ex: VSCode Live Server ou <code>python -m http.server</code>).
      </p>`;
    panel.style.display = 'block';
    _lastStatusOpen = modId;
    return;
  }

  const STATUS_URL = new URL('status.json', document.baseURI).toString();

  let data;
  try {
    const res = await fetch(
      STATUS_URL + (STATUS_URL.includes('?') ? '&' : '?') + 't=' + Date.now(),
      { cache: 'no-store' }
    );
    if (!res.ok) throw new Error('HTTP ' + res.status);
    data = await res.json();
  } catch (e) {
    panel.innerHTML = `<p style="color:#c62828">
      Impossible de charger le statut (${e.message}).<br>
      URL tentée : <code>${STATUS_URL}</code>
    </p>`;
    panel.style.display = 'block';
    _lastStatusOpen = modId;
    return;
  }

  const lang = localStorage.getItem('siteLanguage') || 'fr';
  const info = data[modId];
  if (!info) {
    panel.innerHTML = `<p style="color:#c62828">Aucune information de statut pour ${modId}.</p>`;
    panel.style.display = 'block';
    _lastStatusOpen = modId;
    return;
  }

  // — Badge texte — normalisé
  const stRaw = (info.status || 'dev');
  const s     = normalizeStatus(stRaw);
  const statusLabelText = statusLabel(stRaw, lang);

  // — Date / libellé localisé à côté du badge
  // Essaie d'abord next_update (FR/EN/objet), sinon updated_at
  let dateLabel = "";
  let isIndet = false;
  const rawPlan = (
    pickLocalized(info, 'next_update', lang) ||
    pickLocalized(info, 'updated_at', lang) ||
    ''
  ).toString().trim();

  if (rawPlan) {
    const low = rawPlan.toLowerCase();
    isIndet = ['indeterminee','indéterminée','indetermine','indeterminate','unknown','n/a','-','—','?'].includes(low);

    if (isIndet) {
      dateLabel = (lang === 'fr') ? "Date indéterminée" : "Date indeterminate";
    } else {
      const d = new Date(rawPlan);
      if (isNaN(d)) {
        // 🔸 Texte libre localisé → tel quel (PAS de préfixe)
        dateLabel = rawPlan;
      } else {
        // 🔸 Vraie date → format + préfixe i18n
        const human = d.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US', { year:'numeric', month:'long', day:'numeric' });
        dateLabel = (translations[lang].planned_update || '') + human;
      }
    }
  }

  // — Description + fonctionnalités (déjà bi-langue dans ton JSON)
  const desc  = (lang === 'fr') ? (info.description_fr || '') : (info.description_en || '');
  const feats = (lang === 'fr') ? (info.features_fr || [])    : (info.features_en || []);
  const featsHtml = feats.length
    ? `<h3 data-translate="planned_features">${translations[lang].planned_features}</h3>
       <ul>${feats.map(li => `<li>${li}</li>`).join('')}</ul>`
    : '';

  // — Progression (seulement si pas stable)
  const progress = (typeof info.progress === 'number') ? Math.max(0, Math.min(100, info.progress)) : null;
  const progressHtml = (progress !== null && s !== 'stable')
    ? `
      <h3 data-translate="progress_label">${translations[lang].progress_label}</h3>
      <div class="status-progress">
        <div class="fill" style="width:${progress}%">${progress}%</div>
      </div>`
    : '';

  // — Rendu final
  const title = translations[lang].mod_status_title;
  panel.innerHTML = `
    <div class="status-header">
      <div class="status-badge ${s}">${statusLabelText}</div>
      ${dateLabel ? `<span class="status-updated-inline${isIndet ? ' is-indet' : ''}">${dateLabel}</span>` : ""}
    </div>
    <h3>${title}</h3>
    <p>${desc}</p>
    ${progressHtml}
    ${featsHtml}
  `;

  try {
    localStorage.setItem('lastPage', modId);
    localStorage.setItem(`${modId}:lastView`, 'status');
  } catch {}
  panel.style.display = 'block';

  const buttons = document.querySelectorAll(`#${modId} .side-buttons .card-btn`);
  buttons.forEach(b => b.classList.remove('active'));
  const statusBtn = Array.from(buttons).find(
    b => b.getAttribute('data-translate') === 'status' ||
         (b.textContent || '').trim().toLowerCase().includes('statut') ||
         (b.textContent || '').trim().toLowerCase().includes('status')
  );
  if (statusBtn) statusBtn.classList.add('active');

  _lastStatusOpen = modId;
}

/********************
 * INIT
 ********************/
function initUI() {
  // Thème & police
  initThemeEtPolice();

  // Menus header
  initMenuLangue();
  initMenuParametres();
  initCardsLayout();
}

// Délégation unique pour les menus Langue & Paramètres (robuste même si le DOM est remplacé)
(function wireHeaderMenusOnce() {
  if (window.__headerMenusWired) return;
  window.__headerMenusWired = true;

  document.addEventListener('click', (e) => {
    const langSelector = document.querySelector('.lang-selector');
    const settingsMenu = document.getElementById('settingsMenu');

    const langBtn      = e.target.closest('#currentLangBtn');   // bouton langue
    const settingsBtn  = e.target.closest('#settingsToggle');   // bouton ⚙
    const langOption   = e.target.closest('.lang-option');      // option FR/EN dans le dropdown
    const insideLang   = e.target.closest('.lang-selector');    // clic à l'intérieur du bloc langue
    const insideSettings = e.target.closest('#settingsMenu');   // clic à l'intérieur du bloc paramètres

    // Clic sur le bouton langue
    if (langBtn) {
      e.stopPropagation();
      settingsMenu?.classList.remove('open');           // ferme ⚙ d'abord
      langSelector?.classList.toggle('open');           // toggle menu langue
      return;
    }

    // Clic sur le bouton ⚙
    if (settingsBtn) {
      e.stopPropagation();
      langSelector?.classList.remove('open');           // ferme langue d'abord
      settingsMenu?.classList.toggle('open');           // toggle menu ⚙
      return;
    }

    // Clic sur une option de langue
    if (langOption) {
      e.stopPropagation();
      const lang = langOption.getAttribute('data-lang') || 'fr';
      setLanguage(lang);                                // applique la langue
      langSelector?.classList.remove('open');           // referme le menu
      return;
    }

    // Clic à l’intérieur d’un des deux menus => ne rien fermer
    if (insideLang || insideSettings) {
      return;
    }

    // Clic ailleurs => fermer les deux
    langSelector?.classList.remove('open');
    settingsMenu?.classList.remove('open');
  }, /* useCapture */ true);
})();

// Mémoriser la catégorie sélectionnée dans mod1/mod2 (sans changer ton filtrage)
(function rememberModFiltersOnce(){
  if (window.__rememberModFilters) return;
  window.__rememberModFilters = true;

  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#mod1 .side-buttons .card-btn[data-type], #mod2 .side-buttons .card-btn[data-type]');
    if (!btn) return;

    const page = btn.closest('.page');        // 'mod1' ou 'mod2'
    const mod  = page ? page.id : null;
    if (!mod) return;

    const type = btn.getAttribute('data-type') || 'all';
    try {
      localStorage.setItem('lastPage', mod);               // la page (mod1/mod2)
      localStorage.setItem(`${mod}:lastView`, 'grid');     // on est en "grille"
      localStorage.setItem(`${mod}:lastType`, type);       // la catégorie cliquée
    } catch {}
  }, true);
})();

/********************
 * Disposition des cartes (2×3 / 3×2)
 ********************/
function getSavedCardsLayout() {
  try {
    return localStorage.getItem('cardsLayout') || '3x2'; // défaut: 3 colonnes × 2 rangées
  } catch { return '3x2'; }
}

function applyCardsLayout(layout) {
  const ids = ['mod1', 'mod2'];
  ids.forEach(id => {
    const sec = document.getElementById(id);
    if (!sec) return;
    sec.classList.remove('layout-2x3', 'layout-3x2');
    sec.classList.add('layout-' + layout);
  });
  // UI du toggle
  document.querySelectorAll('.layout-toggle .layout-btn').forEach(btn => {
    btn.classList.toggle('active', btn.getAttribute('data-layout') === layout);
  });
}

function setCardsLayout(layout) {
  try { localStorage.setItem('cardsLayout', layout); } catch {}
  applyCardsLayout(layout);
}

// Appelé au boot
function initCardsLayout() {
  applyCardsLayout(getSavedCardsLayout());
}

// --- Back to top (Patch Notes + pages de mods) --------------------------------
let _btt = null;
let _bttScrollHandler = null;
let _bttScrollTarget = null;
let _bttResizeHandler = null;
let _bttClickHandler = null;

// pages autorisées (ajoute ici si tu renomme)
const BTT_ALLOWED = new Set(['patchnotes', 'mod1', 'mod2', 'acatar', 'chaosium']);
const BTT_THRESHOLD = 600;   // si c'est la fenêtre qui scrolle
const BTT_INNER_THRESHOLD = 140; // si c'est un conteneur interne

function hideBackToTop(){
  if (_btt){
    _btt.classList.remove('show');
    _btt.style.display = 'none';
  }
}

function setupBackToTop(){
  if (_btt) return;
  const btn = document.createElement('button');
  btn.className = 'back-to-top';
  btn.type = 'button';
  btn.setAttribute('aria-label', 'Haut de page');
  btn.textContent = '↑';
  document.body.appendChild(btn);
  _btt = btn;
}

function getScrollTarget(pageId){
  if (pageId === 'patchnotes') return document.querySelector('#patchnotes .patch-list');
  if (pageId === 'mod1')       return document.querySelector('#mod1 .cards-grid');
  if (pageId === 'mod2')       return document.querySelector('#mod2 .cards-grid');
  return window;
}

function positionBackToTop(target){
  if (!_btt) return;
  const btn = _btt;
  const padX = 12;                 // marge mini vs bords de l’écran
  const offsetTop = (window.innerWidth <= 640) ? 6 : 18; // plus près du haut en mobile

  // cadre visible du scroller (viewport de la grille/liste)
  const rect = (target === window)
    ? { top: 0, left: 0, width: window.innerWidth, height: window.innerHeight }
    : (target?.getBoundingClientRect?.() || { top: 0, left: 0, width: window.innerWidth, height: window.innerHeight });

  // position : HAUT + CENTRE du viewport du scroller
  const left = Math.min(
    Math.max(rect.left + rect.width / 2 - btn.offsetWidth / 2, padX),
    window.innerWidth - padX - btn.offsetWidth
  );
  const top = Math.min(
    rect.top + offsetTop,
    window.innerHeight - btn.offsetHeight - offsetTop
  );

  btn.style.left = left + 'px';
  btn.style.top  = top  + 'px';
}

function updateBackToTop(pageId){
  setupBackToTop();
  const btn = _btt;

  // nettoie anciens listeners
  if (_bttScrollHandler && _bttScrollTarget){
    const old = (_bttScrollTarget === window) ? window : _bttScrollTarget;
    old.removeEventListener('scroll', _bttScrollHandler);
  }
  if (_bttResizeHandler){
    window.removeEventListener('resize', _bttResizeHandler);
    _bttResizeHandler = null;
  }
  if (_bttScrollHandler && _bttScrollTarget){
  const old = (_bttScrollTarget === window) ? window : _bttScrollTarget;
  old.removeEventListener('scroll', _bttScrollHandler);
  if (_bttClickHandler){
    old.removeEventListener('click', _bttClickHandler, true);
  }
}

  _bttScrollHandler = null;
  _bttClickHandler  = null;
  _bttScrollTarget  = null;

  // page non autorisée -> bouton totalement caché
  if (!BTT_ALLOWED.has(pageId)){
    btn.classList.remove('show');
    btn.style.display = 'none';
    return;
  }

  // cible de scroll
  const target = getScrollTarget(pageId) || window;
  _bttScrollTarget = target;

  // click : remonter la cible (fenêtre OU conteneur interne)
  btn.onclick = () => {
    if (target === window) window.scrollTo({ top: 0, behavior: 'smooth' });
    else target.scrollTo({ top: 0, behavior: 'smooth' });
  };

  // gestion de l'apparition + positionnement
  const toggle = () => {
    const isWindow = (target === window);
    const pos = isWindow ? window.scrollY : target.scrollTop;
    const limit = isWindow ? BTT_THRESHOLD : BTT_INNER_THRESHOLD;
    if (pos > limit) btn.classList.add('show'); else btn.classList.remove('show');
    positionBackToTop(target);
  };

  // (ré)abonne
  const el = (target === window) ? window : target;
  el.addEventListener('scroll', toggle, { passive: true });
  // ... après el.addEventListener('scroll', toggle, { passive: true });

const clickDismiss = (e) => {
  // Si on clique une carte ou un lien dans la zone qui défile, on cache le bouton
  if (e.target.closest('.cards-grid .small-card, .cards-grid a, .patch-list .patch-entry, .patch-list a')) {
    hideBackToTop();
  }
};
el.addEventListener('click', clickDismiss, true); // capture = true pour capter même si navigation
  _bttClickHandler = clickDismiss;
  _bttScrollHandler = toggle;

  // visible et positionné (la CSS décide de display initial)
  btn.style.display = '';
  // forcer l’état immédiatement au prochain paint, sans attendre un scroll
  requestAnimationFrame(toggle);
  setTimeout(toggle, 0);
  _bttResizeHandler = () => positionBackToTop(target);
  window.addEventListener('resize', _bttResizeHandler, { passive: true });
}

window.addEventListener('DOMContentLoaded', () => {
  console.log('[INIT] prêt');
  // Applique langue / drapeau dès le départ
  setLanguage(ETAT.langue);

  initUI();
  const saved = localStorage.getItem('lastPage');
  const startPage = (saved && document.getElementById(saved)) ? saved : 'accueil';
  showPage(startPage);
  updateBackToTop(startPage);
});

// Gestion des filtres Patch Notes
document.addEventListener('click', (e) => {
  const btn = e.target.closest('#patchnotes .side-buttons .card-btn[data-cat]');
  if (!btn) return;

  e.preventDefault();

  // retirer .active partout, l'ajouter sur le bouton cliqué
  const group = btn.closest('.side-buttons');
  if (group) group.querySelectorAll('.card-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');

  // sauvegarder le choix
  try { localStorage.setItem('patchnotes:cat', btn.dataset.cat); } catch {}

  // relancer le rendu de la liste filtrée
  renderPatchList();
});

/********************
 * CARTES — loaders & rendu
 ********************/
async function loadCards(modId) {
  if (_cache.cartes[modId]) return _cache.cartes[modId];
  const src = CARD_SOURCES[modId];
  if (!src) return [];
  const url = new URL(src, document.baseURI).toString();
  const res = await fetch(url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(), { cache: 'no-store' });
  if (!res.ok) throw new Error('HTTP ' + res.status);
  const data = await res.json();
  _cache.cartes[modId] = Array.isArray(data) ? data : [];
  return _cache.cartes[modId];
}
// Résout un chemin d'asset *par rapport au JSON* (cards/cards_modX.json)
function resolveAsset(modId, src) {
  if (!src) return '';
  try {
    const base = new URL(CARD_SOURCES[modId], document.baseURI);
    return new URL(src, base).toString();
  } catch {
    return src; // au pire, on renvoie tel quel
  }
}

function renderCards(modId, cards) {
  const gridSel = (modId === 'mod1') ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid;
  const grid = document.querySelector(gridSel);
  if (!grid) return;

  const lang = ETAT.langue || 'fr';

  // --- UL "riche" : *Sous-titre, lignes vides = espace
  const renderRichList = (arr) => {
    const lines = Array.isArray(arr) ? arr : [];
    if (!lines.length) return '';
    return `<ul>${
      lines.map(raw => {
        const txt = (raw ?? '').toString();
        if (!txt.trim()) return `<li class="spacer" style="list-style:none;height:.35rem;"></li>`;
        if (/^\s*\*/.test(txt)) {
          const label = txt.replace(/^\s*\*\s*/, '');
          return `<li class="subhead" style="list-style:none;margin:8px 0 4px;text-indent:-1.15em;padding-left:1.15em;"><strong>${label}</strong></li>`;
        }
        return `<li>${txt}</li>`;
      }).join('')
    }</ul>`;
  };

  // --- SPRITE helper (animation frame par frame, style Minecraft)
  const makeSprite = (sideKey, cfg, targetH, pixelated = true, maxW = null, extraCSS = '') => {
    if (!cfg || !cfg.src) return '';
    // accepter frame_width|height ET frameWidth|Height
    cfg.frame_width  = cfg.frame_width  ?? cfg.frameWidth;
    cfg.frame_height = cfg.frame_height ?? cfg.frameHeight;
    if (!cfg.frames || !cfg.frame_width || !cfg.frame_height) return '';

    const frames = Math.max(1, cfg.frames|0);
    const dir    = (cfg.direction === 'horizontal') ? 'horizontal' : 'vertical';
    const fps    = (cfg.fps && cfg.fps > 0) ? cfg.fps : 6;

    // Taille d'affichage (on garde le ratio d'une frame)
    const dispH  = Math.max(1, targetH|0);
    const ratio  = cfg.frame_width / cfg.frame_height;
    const dispW  = Math.round(dispH * ratio);

    // 1 frame visible = dispW x dispH
    const bgSize = (dir === 'horizontal')
      ? `${dispW * frames}px ${dispH}px`
      : `${dispW}px ${dispH * frames}px`;

    const order     = Array.isArray(cfg.order) ? cfg.order : null;         // ex [0,1,2,3,2,1]
    const durations = Array.isArray(cfg.durations) ? cfg.durations : null; // en ms

    const pxCSS   = pixelated ? 'image-rendering:pixelated;' : 'image-rendering:auto;';
    const maxWcss = (maxW && maxW > 0) ? `max-width:${maxW}px;` : '';

    return `
      <div class="sprite-${sideKey}" data-sprite="1"
           data-frames="${frames}" data-fps="${fps}"
           data-dir="${dir}" data-fw="${cfg.frame_width}" data-fh="${cfg.frame_height}"
           ${order ? `data-order="${order.join(',')}"` : ''}
           ${durations ? `data-durations="${durations.join(',')}"` : ''}
           style="
             width:${dispW}px;height:${dispH}px;
             background-image:url('${resolveAsset(modId, cfg.src)}');
             background-repeat:no-repeat;
             background-position:0 0;
             background-size:${bgSize};
             ${pxCSS}${maxWcss}
             border-radius:8px;
             ${extraCSS}
           "></div>`;
  };

  grid.innerHTML = (cards || []).map(c => {
    const title = (lang === 'en') ? (c.title_en || c.title_fr || '') : (c.title_fr || c.title_en || '');
    const desc  = (lang === 'en') ? (c.description_en || c.description_fr || '') : (c.description_fr || c.description_en || '');

    // ---------- SOURCES d'images : gauche/droite + pools ----------
    // GAUCHE
    const leftPool = Array.isArray(c.image_left_pool) ? c.image_left_pool : [];
    const leftCandidates = leftPool.length ? leftPool : (c.image_left ? [c.image_left] : []);
    let leftIdx = 0;
    if (leftCandidates.length > 1) {
      const mode = c.left_select || 'sticky'; // 'sticky' | 'daily' | 'random'
      if (mode === 'daily') {
        const day = Math.floor(Date.now() / 86400000);
        leftIdx = day % leftCandidates.length;
      } else if (mode === 'random') {
        leftIdx = Math.floor(Math.random() * leftCandidates.length);
      } else {
        const key = 'leftChoice:' + (c.id || 'card');
        const saved = localStorage.getItem(key);
        if (saved !== null && !isNaN(+saved)) leftIdx = (+saved) % leftCandidates.length;
        else { leftIdx = Math.floor(Math.random() * leftCandidates.length); try{localStorage.setItem(key, String(leftIdx));}catch(_){} }
      }
    }
    const leftUrls = leftCandidates.map(raw => resolveAsset(modId, raw));
    const leftSrc  = leftUrls[leftIdx] || '';

    // DROITE
    const rightPool = Array.isArray(c.image_right_pool) ? c.image_right_pool
                    : (Array.isArray(c.image_pool) ? c.image_pool : []); // alias optionnel
    const rightCandidates = rightPool.length ? rightPool : (c.image ? [c.image] : []);
    let rightIdx = 0;
    if (rightCandidates.length > 1) {
      const mode = c.right_select || 'sticky';
      if (mode === 'daily') {
        const day = Math.floor(Date.now() / 86400000);
        rightIdx = day % rightCandidates.length;
      } else if (mode === 'random') {
        rightIdx = Math.floor(Math.random() * rightCandidates.length);
      } else {
        const key = 'rightChoice:' + (c.id || 'card');
        const saved = localStorage.getItem(key);
        if (saved !== null && !isNaN(+saved)) rightIdx = (+saved) % rightCandidates.length;
        else { rightIdx = Math.floor(Math.random() * rightCandidates.length); try{localStorage.setItem(key, String(rightIdx));}catch(_){} }
      }
    }
    const rightUrls = rightCandidates.map(raw => resolveAsset(modId, raw));
    const rightSrc  = rightUrls[rightIdx] || '';

    // Intervalles d’alternance auto (0 = off)
    const leftRotateMs =
      (typeof c.left_rotate_ms === 'number' && c.left_rotate_ms > 0) ? Math.round(c.left_rotate_ms)
      : (typeof c.left_rotate_seconds === 'number' && c.left_rotate_seconds > 0) ? Math.round(c.left_rotate_seconds*1000)
      : 0;
    const rightRotateMs =
      (typeof c.right_rotate_ms === 'number' && c.right_rotate_ms > 0) ? Math.round(c.right_rotate_ms)
      : (typeof c.right_rotate_seconds === 'number' && c.right_rotate_seconds > 0) ? Math.round(c.right_rotate_seconds*1000)
      : 0;

    // Sprites animés (optionnels)
    const leftSprite  = c.left_sprite  || c.image_left_sprite  || null;
    const rightSprite = c.right_sprite || c.image_right_sprite || null;

    // ---------- Image miniature (GRILLE) ----------
    const leftPixel  = (typeof c.image_left_pixelated === 'boolean') ? c.image_left_pixelated : (c.image_pixelated === true);
    const rightPixel = (c.image_pixelated === true);

    const thumbStylesSolo = [
      'display:block','width:100%',
      (c.thumb_cover ? 'object-fit:cover' : 'object-fit:contain'),
      'border-radius:8px','margin-bottom:8px'
    ];
    if (typeof c.thumb_height === 'number' && c.thumb_height > 0) thumbStylesSolo.push(`height:${c.thumb_height}px`);
    else thumbStylesSolo.push('max-height:140px');
    if (rightPixel) thumbStylesSolo.push('image-rendering:pixelated');

    let thumbImg = '';
    if ((leftSrc || leftSprite) && (rightSrc || rightSprite)) {
      // DUO (gauche + droite) — hauteur commune en carte
      const pairH =
        (typeof c.thumb_pair_height === 'number' && c.thumb_pair_height > 0) ? c.thumb_pair_height :
        (typeof c.thumb_right_height === 'number' && c.thumb_right_height > 0) ? c.thumb_right_height :
        (typeof c.thumb_height === 'number' && c.thumb_height > 0) ? c.thumb_height : 110;

      // GAUCHE
      let leftNode = '';
      if (leftSprite) {
        const leftH = (typeof c.thumb_left_height === 'number' && c.thumb_left_height > 0) ? c.thumb_left_height : pairH;
        leftNode = makeSprite('L', leftSprite, leftH, leftPixel);
      } else {
        const leftSizeStyle = (typeof c.thumb_left_width === 'number' && c.thumb_left_width > 0)
          ? `width:${c.thumb_left_width}px;height:${pairH}px;`
          : `height:${(typeof c.thumb_left_height === 'number' && c.thumb_left_height > 0) ? c.thumb_left_height : pairH}px;max-width:${pairH}px;`;
        const rotateAttrs = (leftUrls.length > 1 && leftRotateMs > 0)
          ? ` data-rotate="left" data-urls="${leftUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${leftRotateMs}" data-idx="${leftIdx}" data-ts="${Date.now()}"`
          : '';
        leftNode = `
          <img class="thumb-left" src="${leftSrc}" alt="block"
               onerror="this.style.display='none'"
               ${rotateAttrs}
               style="${leftSizeStyle}object-fit:contain;${leftPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;">`;
      }

      // DROITE
      let rightNode = '';
      if (rightSprite) {
        rightNode = makeSprite('R', rightSprite, pairH, rightPixel);
      } else {
        const rotateAttrs = (rightUrls.length > 1 && rightRotateMs > 0)
          ? ` data-rotate="right" data-urls="${rightUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${rightRotateMs}" data-idx="${rightIdx}" data-ts="${Date.now()}"`
          : '';
        rightNode = `
          <img class="thumb-right" src="${rightSrc}" alt="${(title||'').replace(/"/g,'&quot;')}"
               onerror="this.style.display='none'"
               ${rotateAttrs}
               style="height:${pairH}px;width:auto;object-fit:contain;${rightPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;margin-bottom:8px;flex:0 0 auto;">`;
      }

      thumbImg = `
        <div class="thumb-pair" style="display:flex;align-items:center;justify-content:center;gap:12px;">
          ${leftNode}
          ${rightNode}
        </div>`;
    } else {
      // UNE SEULE IMAGE / SPRITE à droite → centré
      if (rightSrc) {
        thumbImg = `<img class="thumb" src="${rightSrc}" alt="${(title||'').replace(/"/g,'&quot;')}"
                 onerror="this.style.display='none'"
                 style="display:block;margin:0 auto 8px;${thumbStylesSolo.join(';')}">`;
      } else if (rightSprite) {
        const h = (typeof c.thumb_height === 'number' && c.thumb_height > 0) ? c.thumb_height : 110;
        thumbImg = makeSprite('Rsolo', rightSprite, h, rightPixel, null, 'display:block;margin:0 auto 8px;');
      } else {
        thumbImg = '';
      }
    }

    // ---------- Image "preview" (DÉTAIL) ----------
    const previewSrc = rightSrc;
    let detailImg = '';
    if ((previewSrc || rightSprite) && (leftSrc || leftSprite) && c.detail_pair !== false) {
      // Duo en détail : hauteurs indépendantes possibles
      const baseH = (typeof c.detail_pair_height === 'number' && c.detail_pair_height > 0) ? c.detail_pair_height : 180;
      const leftH  = (typeof c.detail_left_height  === 'number' && c.detail_left_height  > 0) ? c.detail_left_height  : baseH;
      const rightH = (typeof c.detail_right_height === 'number' && c.detail_right_height > 0)
                   ? c.detail_right_height
                   : (typeof c.detail_right_scale === 'number' && c.detail_right_scale > 0
                      ? Math.round(baseH * c.detail_right_scale)
                      : baseH);
      const rightMaxW = (typeof c.detail_right_max_width === 'number' && c.detail_right_max_width > 0) ? c.detail_right_max_width : 440;

      // GAUCHE
      let leftDetailNode = '';
      if (leftSprite) {
        leftDetailNode = makeSprite('Ldet', leftSprite, leftH, leftPixel);
      } else {
        const rotateAttrs = (leftUrls.length > 1 && leftRotateMs > 0)
          ? ` data-rotate="left" data-urls="${leftUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${leftRotateMs}" data-idx="${leftIdx}" data-ts="${Date.now()}"`
          : '';
        leftDetailNode = `
          <img src="${leftSrc}" alt="block"
               onerror="this.style.display='none'"
               ${rotateAttrs}
               style="height:${leftH}px;width:auto;${leftPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;">`;
      }

      // DROITE
      let rightDetailNode = '';
      if (rightSprite) {
        rightDetailNode = makeSprite('Rdet', rightSprite, rightH, rightPixel, rightMaxW);
      } else {
        const rotateAttrs = (rightUrls.length > 1 && rightRotateMs > 0)
          ? ` data-rotate="right" data-urls="${rightUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${rightRotateMs}" data-idx="${rightIdx}" data-ts="${Date.now()}"` : '';
        rightDetailNode = `
          <img src="${previewSrc}" alt="${(title||'').replace(/"/g,'&quot;')}"
               onerror="this.style.display='none'"
               ${rotateAttrs}
               style="height:${rightH}px;max-width:${rightMaxW}px;width:auto;${rightPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;flex:0 0 auto;">`;
      }

      detailImg = `
        <div class="detail-pair" style="display:flex;align-items:flex-start;justify-content:center;gap:12px;margin:8px 0 12px;">
          ${leftDetailNode}
          ${rightDetailNode}
        </div>`;
    } else {
      // Sprite/IMG seule à droite → centré
      const detailImgStylesSolo = ['border-radius:8px','display:block','margin:8px auto 12px','max-width:440px','width:100%'];
      if (rightPixel) detailImgStylesSolo.push('image-rendering:pixelated');

      if (previewSrc) {
        detailImg = `<img src="${previewSrc}" alt="${(title||'').replace(/"/g,'&quot;')}"
                    onerror="this.style.display='none'" style="${detailImgStylesSolo.join(';')}">`;
      } else if (rightSprite) {
        const baseH =
          (typeof c.detail_right_height === 'number' && c.detail_right_height > 0) ? c.detail_right_height :
          (typeof c.detail_pair_height === 'number' && c.detail_pair_height > 0) ? c.detail_pair_height : 180;
        const maxW = (typeof c.detail_right_max_width === 'number' && c.detail_right_max_width > 0) ? c.detail_right_max_width : 440;
        detailImg = makeSprite('RsoloDet', rightSprite, baseH, rightPixel, maxW, 'display:block;margin:8px auto 12px;');
      } else {
        detailImg = '';
      }
    }

// ---------- Sections libres & extras ----------
const details  = c.details || {};
const sections = Array.isArray(details.sections) ? details.sections : [];

const sectionsHtml = sections.map(sec => {
  // ❌ plus de fallback vers l'autre langue
  const stitle = (lang === 'en') ? (sec.title_en  || '') : (sec.title_fr  || '');
  const sitems = (lang === 'en') ? (sec.items_en  || []) : (sec.items_fr  || []);

  // ✅ on n'accepte que la langue courante, avec fallback éventuel vers un champ neutre "images"/"captions"
  const imgs = (lang === 'en')
    ? (sec.images_en   || sec.images || [])
    : (sec.images_fr   || sec.images || []);

  const caps = (lang === 'en')
    ? (sec.captions_en || sec.captions || [])
    : (sec.captions_fr || sec.captions || []);

  // ⛔ ignorer la section si elle n'a rien pour cette langue
  const hasContent = (stitle && stitle.trim()) || sitems.length || imgs.length;
  if (!hasContent) return '';

  const imgsHtml = imgs.length
  ? `<div class="section-images">
       ${imgs.map((raw, i) => {
         const src = resolveAsset(modId, raw);
         const cap = (caps[i] || '').trim();
         return `
           <figure class="sec-figure">
             ${cap ? `<figcaption class="sec-figcap">${cap}</figcaption>` : ''}
             <img class="sec-img"
                  src="${src}"
                  alt="${(stitle||title||'').replace(/"/g,'&quot;')}"
                  onerror="this.style.display='none'">
           </figure>`;
       }).join('')}
     </div>`
  : '';


  const listHtml = sitems.length ? `<ul style="padding-left:1.15em;">${
    sitems.map(it => {
      const txt = (it ?? '').toString();
      if (!txt.trim()) return `<li class="spacer" style="list-style:none;height:.35rem;"></li>`;
      if (/^\s*\*/.test(txt)) {
        const label = txt.replace(/^\s*\*\s*/, '');
        return `<li class="subhead" style="list-style:none;margin:8px 0 4px;text-indent:-1.15em;padding-left:1.15em;"><strong>${label}</strong></li>`;
      }
      return `<li>${txt}</li>`;
    }).join('')
  }</ul>` : '';

  return `${stitle ? `<h4 class="underline">${stitle}</h4>` : ''}${listHtml}${imgsHtml}`;
}).join('');

const craft = details[lang === 'en' ? 'craft_en' : 'craft_fr'] || [];
const usage = details[lang === 'en' ? 'usage_en' : 'usage_fr'] || [];
const drops = details[lang === 'en' ? 'drops_en' : 'drops_fr'] || [];
const extrasHtml = `
  ${craft.length ? `<h4 class="underline">${(translations?.[lang]?.craft)||'Craft'}</h4>${renderRichList(craft)}` : ''}
  ${usage.length ? `<h4 class="underline">${(translations?.[lang]?.usage)||'Usage'}</h4>${renderRichList(usage)}` : ''}
  ${drops.length ? `<h4 class="underline">${(translations?.[lang]?.drops)||'Drops'}</h4>${renderRichList(drops)}` : ''}
`;


    // ---------- Contenu détail dans data-attr ----------
    const detailHtml = `
      ${detailImg}
      ${desc ? `<p>${desc}</p>` : ''}
      ${sectionsHtml}
      ${extrasHtml}
    `.trim().replace(/"/g, '&quot;');

    // ---------- Render de la carte ----------
    return `
      <div class="small-card ${c.type || ''}"
           data-id="${c.id || ''}"
           data-description="${detailHtml}"
           onclick="showCardDetail('${modId}', this)">
        ${thumbImg}
        <h4>${title}</h4>
        ${desc ? `<p>${desc}</p>` : ''}
      </div>`;
  }).join('');

  // Réapplique le filtre latéral actif
  const page = grid.closest('.page');
  const activeBtn = page?.querySelector('.side-buttons .card-btn.active');
  const type = activeBtn?.getAttribute('data-type') || 'all';
  if (type !== 'all') {
    grid.querySelectorAll('.small-card').forEach(card => {
      card.style.display = card.classList.contains(type) ? 'block' : 'none';
    });
  }

  // Ticker global pour l'alternance d'images (non-sprite)
  if (!window.__rotateTicker) {
    window.__rotateTicker = setInterval(() => {
      const now = Date.now();
      document.querySelectorAll('img[data-rotate]').forEach(img => {
        const ms = parseInt(img.getAttribute('data-ms'), 10) || 3000;
        const ts = parseInt(img.getAttribute('data-ts'), 10) || 0;
        if (now - ts < ms) return;
        let urls = img.__urls;
        if (!urls) {
          const raw = img.getAttribute('data-urls') || '';
          urls = raw.split(',').map(s => decodeURIComponent(s)).filter(Boolean);
          img.__urls = urls;
        }
        if (urls.length < 2) return;
        let idx = parseInt(img.getAttribute('data-idx'), 10) || 0;
        idx = (idx + 1) % urls.length;
        img.src = urls[idx];
        img.setAttribute('data-idx', String(idx));
        img.setAttribute('data-ts', String(now));
      });
    }, 500);
  }

  // Lancer/assurer l'animateur de sprites (frame par frame)
  if (typeof ensureSpriteAnimator === 'function') ensureSpriteAnimator();
}


function ensureSpriteAnimator() {
  if (window.__spriteAnim) return;

  function initNewSprites() {
    document.querySelectorAll('[data-sprite="1"]').forEach(el => {
      if (el.__spr) return;

      const frames = parseInt(el.dataset.frames, 10) || 1;
      const fps    = parseFloat(el.dataset.fps) || 6;
      const dir    = el.dataset.dir === 'horizontal' ? 'horizontal' : 'vertical';

      // ordre & durées personnalisés (ms), façon .mcmeta
      const order = (el.dataset.order || '')
        .split(',').map(x => parseInt(x,10))
        .filter(n => !isNaN(n) && n >= 0 && n < frames);
      const durations = (el.dataset.durations || '')
        .split(',').map(x => parseInt(x,10)).filter(n => !isNaN(n) && n > 0);

      const dispW = el.clientWidth  || parseInt(getComputedStyle(el).width, 10);
      const dispH = el.clientHeight || parseInt(getComputedStyle(el).height, 10);

      el.__spr = {
        frames, fps, dir, dispW, dispH,
        idx: 0,
        order: order.length ? order : null,
        durations: durations.length ? durations : null,
        next: performance.now() + (durations.length ? durations[0] : 1000 / fps)
      };
    });
  }

  function step(t) {
    document.querySelectorAll('[data-sprite="1"]').forEach(el => {
      const s = el.__spr; if (!s) return;

      if (t >= s.next) {
        // avance l’index (ordre custom si présent)
        if (s.order) {
          const pos = s.order.indexOf(s.idx);
          const nextPos = (pos + 1) % s.order.length;
          s.idx = s.order[nextPos];
        } else {
          s.idx = (s.idx + 1) % s.frames;
        }

        // déplacement EXACT d'une frame à l'autre
        const offX = (s.dir === 'horizontal') ? -(s.dispW * s.idx) : 0;
        const offY = (s.dir === 'vertical')   ? -(s.dispH * s.idx) : 0;
        el.style.backgroundPosition = `${offX}px ${offY}px`;

        // prochaine échéance (durations[] sinon 1000/fps)
        const base = s.durations
          ? s.durations[(s.order ? s.order.indexOf(s.idx) : s.idx) % s.durations.length]
          : (1000 / s.fps);
        s.next = t + base;
      }
    });
    requestAnimationFrame(step);
  }

  // Observe les ajouts de nœuds (ex : ouverture d’un détail)
  const mo = new MutationObserver(initNewSprites);
  mo.observe(document.body, { childList: true, subtree: true });

  initNewSprites();
  requestAnimationFrame(step);
  window.__spriteAnim = true;
}



async function ensureCards(modId, opts = {}) {
  const gridSel = (modId === 'mod1') ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid;
  const grid = document.querySelector(gridSel);
  if (!grid) return;

  // option pour forcer le rechargement (clear cache)
  if (opts.force && _cache?.cartes) {
    _cache.cartes[modId] = null;
  }

  try {
    const data = await loadCards(modId);
    if (Array.isArray(data) && data.length) {
      renderCards(modId, data);

      // réappliquer le filtre actif (si autre que "all")
      const page = grid.closest('.page');
      const activeBtn = page?.querySelector('.side-buttons .card-btn.active');
      const type = activeBtn?.getAttribute('data-type') || 'all';
      if (type !== 'all') {
        grid.querySelectorAll('.small-card').forEach(card => {
          card.style.display = card.classList.contains(type) ? 'block' : 'none';
        });
      }
    } else {
      // si rien dans le JSON et aucune carte HTML déjà présente → petit message
      if (!grid.querySelector('.small-card')) {
        grid.innerHTML = `<p style="opacity:.7">Aucune carte trouvée. Vérifie <code>${CARD_SOURCES[modId]}</code>.</p>`;
      }
    }
  } catch (e) {
    // si parse/404 et grille vide → message clair
    if (!grid.querySelector('.small-card')) {
      grid.innerHTML = `<p style="color:#c62828">Impossible de charger <code>${CARD_SOURCES[modId]}</code> (${e.message}).</p>`;
    } else {
      console.warn('[cards]', modId, e);
    }
  }

  grid.querySelectorAll('img').forEach(img => {
    if (!img.hasAttribute('loading')) img.setAttribute('loading','lazy');
  });
}

/********************
 * CARTES — forcer l'affichage de la grille
 ********************/
function showCards(modId) {
  const page   = document.getElementById(modId);
  if (!page) return;

  const grid   = page.querySelector('.cards-grid');
  const detail = page.querySelector('.card-detail');
  const status = page.querySelector('.update-panel');

  // Ferme Statut + le panneau détail
  if (status) status.style.display = 'none';
  if (detail) detail.style.display = 'none';

  // Ré-affiche explicitement la grille en "grid"
  if (grid) grid.style.display = 'grid';
}


/********************
 * INIT — Bouton "← Retour" (Patchnotes)
 ********************/
(function wirePatchBackOnce() {
  if (window.__patchBackWired) return;
  window.__patchBackWired = true;

  document.addEventListener('click', (e) => {
    const back = e.target.closest('#patchnotes .back-btn');
    if (!back) return;
    e.preventDefault();

    // Si tu as showPatchList(), on l’utilise, sinon on retombe sur hideCardDetail('patchnotes')
    if (typeof showPatchList === 'function') {
      showPatchList();
    } else if (typeof hideCardDetail === 'function') {
      hideCardDetail('patchnotes');
    }
  }, true);
})();

// INIT — Bouton "← Retour" (Cartes des mods)
(function wireCardBackOnce(){
  if (window.__cardBackWired) return;
  window.__cardBackWired = true;

  document.addEventListener('click', (e) => {
    const back = e.target.closest('#mod1 .card-detail .back-btn, #mod2 .card-detail .back-btn');
    if (!back) return;
    e.preventDefault();

    // 1) Si l’URL contient déjà une carte (…#p=modX&card=...), on remonte l'historique navigateur
    const sp = new URLSearchParams((location.hash || '').slice(1));
    if (sp.get('card')) { history.back(); return; }

    // 2) Sinon on ferme simplement le détail pour revenir à la grille
    const page = back.closest('.page');
    if (page && typeof hideCardDetail === 'function') {
      hideCardDetail(page.id); // "mod1" | "mod2"
    }
  }, true);
})();

/********************
 * INIT — Recherche & filtres des cartes (délégation, fix)
 ********************/
(function wireCardsUIOnce(){
  if (window.__cardsWired) return;
  window.__cardsWired = true;

  // Ferme Statut & Détail et ré-affiche la grille, en rechargeant si besoin
  async function ensureGridVisibleFrom(el) {
    const page = el.closest('.page');
    if (!page) return;
    const grid   = page.querySelector('.cards-grid');
    const detail = page.querySelector('.card-detail');
    const status = page.querySelector('.update-panel');

    if (status) status.style.display = 'none';
    if (detail) detail.style.display = 'none';
    if (!grid) return;

    // Remet la grille visible
    grid.style.display = 'grid';

    // Si aucune carte, on recharge la source JSON
    if (!grid.querySelector('.small-card')) {
      const modId = page.id; // "mod1" | "mod2"
      if (typeof ensureCards === 'function') {
        try { await ensureCards(modId); } catch(_) {}
      }
    }
  }

// Frappe dans la recherche : suggestions UNIQUEMENT (la grille ne bouge pas)
document.addEventListener('input', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;
  showSuggestions(input); // ta fonction de suggestions
}, true);


  // Filtres side-menu : <button class="card-btn" data-type="bloc|item|mob|all">
  document.addEventListener('click', async (e) => {
    const btn = e.target.closest('.side-buttons .card-btn[data-type]');
    if (!btn) return;

    await ensureGridVisibleFrom(btn);

    const page = btn.closest('.page');
    const grid = page?.querySelector('.cards-grid');
    if (!grid) return;

    // activer visuellement
    const group = btn.parentElement;
    if (group) group.querySelectorAll('.card-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');

    // appliquer le filtre
    const type = btn.getAttribute('data-type') || 'all';
    grid.querySelectorAll('.small-card').forEach(card => {
      card.style.display = (type === 'all' || card.classList.contains(type)) ? 'block' : 'none';
    });
  }, true);

  // === Suggestions de recherche (titres uniquement)
function ensureWrap(input){
  if (input.parentElement && input.parentElement.classList.contains('search-wrap')) return input.parentElement;
  const wrap = document.createElement('div');
  wrap.className = 'search-wrap';
  input.parentNode.insertBefore(wrap, input);
  wrap.appendChild(input);
  return wrap;
}
function ensureSuggestBox(wrap){
  let box = wrap.querySelector('.search-suggest');
  if (!box) {
    box = document.createElement('div');
    box.className = 'search-suggest';
    wrap.appendChild(box);
  }
  return box;
}
function buildSuggestions(input){
  const page = input.closest('.page');
  const grid = page?.querySelector('.cards-grid');
  if (!grid) return [];

  const qn = normalizeText(input.value || '');
  if (qn.length < 2) return [];

  const seen = new Set();
  const out = [];
  grid.querySelectorAll('.small-card').forEach(card => {
    const id = card.getAttribute('data-id') || '';
    const title = (card.querySelector('h4')?.textContent || '').trim();
    const tn = normalizeText(title);
    if (title && tn.includes(qn) && !seen.has(id)) {
      seen.add(id);
      out.push({ id, title, el: card });
    }
  });
  return out.slice(0, 8);
}
function showSuggestions(input){
  const wrap = ensureWrap(input);
  const box  = ensureSuggestBox(wrap);
  const sugs = buildSuggestions(input);

  if (!sugs.length) { box.classList.remove('open'); box.innerHTML = ''; return; }

  box.innerHTML = sugs.map((s,i) =>
    `<button type="button" data-id="${s.id}" ${i===0?'aria-selected="true"':''}>${s.title}</button>`
  ).join('');
  box.classList.add('open');

  // clic = ouvrir la carte (ou juste filtrer)
  box.onclick = (e) => {
    const btn = e.target.closest('button[data-id]');
    if (!btn) return;
    const page = input.closest('.page');
    const modId = page?.id || 'mod1';
    // Ouvre le détail de la carte :
    const gridSel = (modId === 'mod1') ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid;
    const card = document.querySelector(`${gridSel} .small-card[data-id="${btn.dataset.id}"]`);
    if (card) showCardDetail(modId, card);
    box.classList.remove('open');
  };
}

// input/focus => MAJ suggestions
document.addEventListener('input', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;
  showSuggestions(input);
}, true);
document.addEventListener('focusin', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;
  showSuggestions(input);
}, true);

// navigation clavier
document.addEventListener('keydown', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;
  const box = input.parentElement?.querySelector('.search-suggest.open');
  if (!box) return;

  const items = Array.from(box.querySelectorAll('button[data-id]'));
  if (!items.length) return;

  const idx = Math.max(0, items.findIndex(b => b.getAttribute('aria-selected') === 'true'));
  if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
    e.preventDefault();
    const next = (e.key === 'ArrowDown') ? Math.min(items.length-1, idx+1) : Math.max(0, idx-1);
    items.forEach(b => b.removeAttribute('aria-selected'));
    items[next].setAttribute('aria-selected', 'true');
    items[next].scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'Enter') {
    e.preventDefault();
    items[idx].click();
  } else if (e.key === 'Escape') {
    box.classList.remove('open');
  }
});

// Entrée quand la dropdown n'est PAS ouverte => appliquer la recherche (filtrer la grille)
document.addEventListener('keydown', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;

  // Si la dropdown est ouverte, on ne fait rien ici (la navigation au-dessus gère Enter)
  const box = input.parentElement?.querySelector('.search-suggest.open');
  if (box) return;

  if (e.key === 'Enter') {
    e.preventDefault();
    const page = input.closest('.page');
    const modId = page?.id; // "mod1" ou "mod2"
    if (modId && typeof searchCards === 'function') {
      searchCards(modId, input.value || '');
    }
    // (Optionnel) si tu utilises mon module d'URL (#p=...&q=...), mets à jour le hash ici :
    if (typeof setParams === 'function') {
      setParams({ p: modId, q: input.value || '' }, true);
    }
  }
}, true);

// clic ailleurs => ferme
document.addEventListener('click', (e) => {
  const open = document.querySelector('.search-suggest.open');
  if (!open) return;
  if (!e.target.closest('.search-wrap')) open.classList.remove('open');
}, true);

})();

function notifyCopied(ok){
  const lang = localStorage.getItem('siteLanguage') || 'fr';
  const msg  = ok ? (lang === 'en' ? 'Link copied!' : 'Lien copié !')
                  : (lang === 'en' ? 'Copy failed'  : 'Échec de la copie');
  try { 
    // simple toast via alert pour rester vanilla
    alert(msg);
  } catch(_) {}
}

// Délégation de clic sur tous les boutons .link-copy-btn
(function wireCopyLinkOnce(){
  if (window.__copyLinkWired) return;
  window.__copyLinkWired = true;

  document.addEventListener('click', async (e) => {
  const btn = e.target.closest('.link-copy-btn');
  if (!btn) return;
  e.preventDefault();

  const ctx = btn.getAttribute('data-context') || btn.closest('.page')?.id || '';
  const url = (typeof buildDeepLink === 'function') ? buildDeepLink(ctx) : (location.origin + location.pathname + (location.hash || ''));

  let copied = false;
  try {
    await navigator.clipboard.writeText(url);
    copied = true;
  } catch {
    // Fallback si le navigateur bloque la copie
    try { window.prompt('Copie manuelle :', url); } catch {}
  }

  // Petit feedback visuel
  const old = btn.textContent;
  btn.textContent = copied ? '✅ Lien copié' : '📋 Copier le lien';
  setTimeout(()=> btn.textContent = old, 1200);

  // 👇 Nouveau : proposer d'ouvrir le lien tout de suite dans un nouvel onglet
  const lang = (localStorage.getItem('siteLanguage') || 'fr');
  const ask  = (lang === 'en') ? 'Open this link now?' : 'Ouvrir ce lien maintenant ?';
  if (window.confirm(ask)) {
    window.open(url, '_blank', 'noopener,noreferrer');
  }
}, true);
})();

// Clic sur la PASTILLE de statut uniquement (pas le nom)
document.addEventListener('click', (e)=>{
  const pill = e.target.closest('#home-status .status-pill');
  if (!pill) return;
  e.preventDefault();

  const chip = pill.closest('.status-chip');
  const mod  = chip && chip.getAttribute('data-mod'); // "mod1" | "mod2"
  if (!mod) return;

  if (typeof setParams === 'function') setParams({ p: mod, view: 'status' }, true);
  if (typeof showPage === 'function') showPage(mod);
  if (typeof showStatus === 'function') showStatus(mod);
}, true);

// Clavier : Enter/espace sur la pastille = clic
document.addEventListener('keydown', (e)=>{
  const pill = e.target.closest('#home-status .status-pill');
  if (!pill) return;
  if (e.key !== 'Enter' && e.key !== ' ') return;
  e.preventDefault();
  pill.click();
});

/********************
 * INIT — Bandeau : lien actif
 ********************/
(function wireHeaderNavActive(){
  if (window.__navActiveWired) return;
  window.__navActiveWired = true;

  function setActiveNavById(pageId) {
    const links = document.querySelectorAll('.bandeau nav a');
    links.forEach(a => {
      const href = a.getAttribute('href') || '';
      const data = a.getAttribute('data-page') || '';
      const target =
        (data || '').replace(/^#/, '') ||
        (href.includes('#') ? href.split('#').pop() : '').replace(/^#/, '');
      a.classList.toggle('active', target === pageId);
    });
  }

  // clique sur le bandeau
  document.addEventListener('click', (e) => {
    const a = e.target.closest('.bandeau nav a');
    if (!a) return;
    const href = a.getAttribute('href') || '';
    const data = a.getAttribute('data-page') || '';
    const pageId = (data || (href.includes('#') ? href.split('#').pop() : '')).replace(/^#/, '');
    if (pageId) setActiveNavById(pageId);
  }, true);

  // expose une fonction globale pour l’utiliser depuis showPage(id)
  window.__setActiveNavById = setActiveNavById;
})();

// ==== INIT: Chips de statut sous le header (Accueil) ====
(function initHomeStatusOnce(){
  if (window.__homeStatusInit) return; window.__homeStatusInit = true;

  async function loadStatus(){
    try{
      const res = await fetch('status.json?t=' + Date.now(), { cache:'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      return await res.json();
    }catch(_){ return {}; }
  }
  function labelFor(s, lang){
    const st = (s||'').toLowerCase();
    if (lang==='en') return st==='stable'?'Stable': st==='beta'?'Beta':'In development';
    return st==='stable'?'Stable': st==='beta'?'Bêta':'En développement';
  }

  function classFor(s){
    const st = (s||'').toLowerCase();
    return st==='stable'?'is-stable': st==='beta'?'is-beta':'is-dev';
  }

  // Mappe ce qui vient de status.json vers une classe CSS connue
 function normalizeStatus(s) {
   const t = (s || '').toLowerCase().trim();
   if (t === 'release') return 'stable'; // <= ici on force "release" à devenir "stable"
   if (t === 'developpement' || t === 'en développement' || t === 'development' || t === 'in development')
     return 'dev';
   return t; // stable | beta | dev | (autres inchangés)
 }

 // Libellé à afficher (FR/EN) à partir de la valeur brute du JSON
 function statusLabel(raw, lang) {
   const t = (raw || '').toLowerCase().trim();
   if (t === 'release' || t === 'stable') return (lang === 'en') ? 'Stable' : 'Stable';
   if (t === 'beta')                         return (lang === 'en') ? 'Beta'   : 'Bêta';
   // tout le reste (dev, in development, etc.)
   return (lang === 'en') ? 'In development' : 'En développement';
}


  function paint(map){
  const lang = localStorage.getItem('siteLanguage') || 'fr';
  document.querySelectorAll('#home-status .status-chip').forEach(btn=>{
    const mod    = btn.getAttribute('data-mod');            // "mod1" | "mod2"
    const name   = (mod==='mod1' ? 'Acatar' : mod==='mod2' ? 'Chaosium' : (mod||''));
    const stRaw  = map?.[mod]?.status || '';                // ex: "release"
    const stNorm = normalizeStatus(stRaw);                  // -> "stable"
    const label  = statusLabel(stRaw, lang);                // -> "Stable"

    // "Nom : [pastille]"
    btn.innerHTML =
      `<span class="mod-name">${name}</span><span class="sep" aria-hidden="true">:</span>
      <span class="status-pill ${stNorm || ''}" tabindex="0" role="button"
            aria-label="${(lang==='en'?'Open status: ':'Ouvrir le statut : ')+name}">
        ${label}
      </span>`;
    if (stNorm) btn.setAttribute('data-status', stNorm);
  });
  }


  // 👇 expose un refresh global (utile quand on change la langue)
  window.__refreshHomeChips = () => loadStatus().then(paint);

  // premier rendu
  window.__refreshHomeChips();
})();

// Ajoute/actualise le petit titre "Statut :" dans #home-status
function ensureStatusTitle(){
  const bar = document.getElementById('home-status');
  if (!bar) return;

  // crée le titre s'il n'existe pas
  let title = bar.querySelector('.status-title');
  if (!title) {
    title = document.createElement('span');
    title.className = 'status-title';
    title.setAttribute('aria-hidden', 'true'); // non interactif
    bar.prepend(title);
  }
  const lang = (localStorage.getItem('siteLanguage') || 'fr');
  title.textContent = (lang === 'en') ? 'Status:' : 'Statut :';
}

// S’assure que le bon lien est actif après recharge
window.addEventListener('DOMContentLoaded', () => {
  const visible = Array.from(document.querySelectorAll('.page'))
    .find(p => getComputedStyle(p).display !== 'none');
  const id = visible ? visible.id : 'accueil';
  document.querySelectorAll('.bandeau nav a').forEach(a => a.classList.remove('active'));
  const nav = document.getElementById('nav-' + id);
  if (nav) nav.classList.add('active');
});

// Drawer mobile
(function wireMobileDrawer(){
  const drawer = document.getElementById('mobileDrawer');
  const btn    = document.getElementById('mobileMenuBtn');
  if (!drawer || !btn) return;

  function openDrawer(){
    drawer.classList.add('open');
    drawer.setAttribute('aria-hidden', 'false');
    btn.setAttribute('aria-expanded', 'true');
  }
  function closeDrawer(){
    drawer.classList.remove('open');
    drawer.setAttribute('aria-hidden', 'true');
    btn.setAttribute('aria-expanded', 'false');
  }
  window.openPageFromDrawer = function(pageId){
    showPage(pageId);
    closeDrawer();
  };

  btn.addEventListener('click', (e)=>{ e.stopPropagation(); drawer.classList.contains('open') ? closeDrawer() : openDrawer(); });
  drawer.addEventListener('click', (e)=>{ if (e.target.matches('[data-close], .drawer-backdrop')) closeDrawer(); });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeDrawer(); });
})();

// Ouvre le panneau Paramètres depuis le drawer
function openSettingsPanel() {
  const settingsMenu   = document.getElementById('settingsMenu');   // wrapper du bouton ⚙ + panneau
  const settingsPanel  = document.getElementById('settingsPanel');  // le panneau
  const langSelector   = document.querySelector('.lang-selector');  // le menu langue (à fermer)

  if (!settingsMenu || !settingsPanel) return;

  // Fermer la langue si ouverte
  if (langSelector) langSelector.classList.remove('open');

  // Ouvrir le panneau paramètres (compat .open ET .panel-open)
  settingsMenu.classList.add('open');
  settingsMenu.classList.add('panel-open');

  // Ceinture + bretelles si une règle CSS met display:none
  settingsPanel.style.display = 'block';

  // ARIA (facultatif)
  const toggle = document.getElementById('settingsToggle');
  if (toggle) toggle.setAttribute('aria-expanded', 'true');
}

// Ouvrir le panneau Paramètres depuis le drawer (en différé pour éviter le close global)
function openSettingsFromDrawer(e) {
  if (e) { e.preventDefault(); e.stopPropagation(); }
  // ferme le drawer d'abord
  if (typeof closeDrawer === 'function') closeDrawer();
  // puis ouvre les paramètres après la fin de ce clic
  setTimeout(() => {
    const btn = document.getElementById('settingsToggle');
    if (btn) btn.click(); // utilise ta logique existante d'ouverture
  }, 80);
  return false;
}

function setThemeFromDrawer(cls) {
  ETAT.theme = cls;
  localStorage.setItem('siteTheme', cls);
  if (typeof appliquerThemeEtPolice === 'function') {
    appliquerThemeEtPolice();
  } else if (typeof applyThemeAndFont === 'function') {
    applyThemeAndFont();
  } else {
    const root = document.documentElement;
    root.classList.remove('theme-sombre','theme-clair', 'theme-bleu');
    root.classList.add(cls);
  }
}

function setFontFromDrawer(cls) {
  ETAT.fontSize = cls;
  localStorage.setItem('siteFont', cls);
  if (typeof appliquerThemeEtPolice === 'function') {
    appliquerThemeEtPolice();
  } else if (typeof applyThemeAndFont === 'function') {
    applyThemeAndFont();
  } else {
    const root = document.documentElement;
    root.classList.remove('font-normal','font-grand','font-tres-grand');
    root.classList.add(cls);
  }
}

// ---------- Liens entre cartes (ex: <a data-card-id="baton_forge">Bâton forgé</a>)
function gotoCard(modId, cardId) {
  // revenir sur la grille si un panneau est ouvert
  if (typeof showCards === 'function') showCards(modId);

  const gridSel = (modId === 'mod1') ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid;
  const grid = document.querySelector(gridSel);
  if (!grid) return;

  // essaie d'ouvrir tout de suite
  let el = grid.querySelector(`.small-card[data-id="${cardId}"]`);
  if (el) {
    showCardDetail(modId, el);
    try { el.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_){}
    return;
  }

  // si la carte n'est pas encore rendue, (re)charge et réessaie
  if (typeof ensureCards === 'function') ensureCards(modId);
  setTimeout(() => {
    el = grid.querySelector(`.small-card[data-id="${cardId}"]`);
    if (el) showCardDetail(modId, el);
  }, 120);
}

// capture les clics sur <a data-card-id="...">
document.addEventListener('click', (e) => {
  const link = e.target.closest('a[data-card-id]');
  if (!link) return;

  e.preventDefault();
  // déduire le mod depuis la page courante
  const page = link.closest('.page');
  const modId =
    page?.id ||
    (document.getElementById('mod1')?.style.display !== 'none' ? 'mod1' : 'mod2');

  const targetId = link.getAttribute('data-card-id');
  if (targetId) gotoCard(modId, targetId);
}, true);

/********************
 * NAVIGATION ENTRE CARTES (pile d'historique sans double push)
 ********************/
(function wireCardHistory() {
  if (window.__cardHistoryWired) return;
  window.__cardHistoryWired = true;

  const HISTORY = { mod1: [], mod2: [], backNav: false };

  const getDetailEl  = (m) => document.querySelector(`#${m} .card-detail`);
  const getCurrentId = (m) => getDetailEl(m)?.getAttribute('data-current-card-id') || null;
  const setCurrentId = (m, id) => { const d = getDetailEl(m); if (d) d.setAttribute('data-current-card-id', id || ''); };
  const gridSel      = (m) => (m === 'mod1' ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid);

  // --- showCardDetail : push l'ancienne carte (sauf pendant un "retour")
  const origShow = window.showCardDetail;
  if (typeof origShow === 'function') {
    window.showCardDetail = function(modId, el, ...rest) {
      try {
        const curr = getCurrentId(modId);
        const next = el?.getAttribute('data-id');
        if (!HISTORY.backNav && curr && next && curr !== next) {
          (HISTORY[modId] ||= []).push(curr);
        }
      } catch (_) {}
      const res = origShow.apply(this, [modId, el, ...rest]);
      try { setCurrentId(modId, el?.getAttribute('data-id') || null); } catch (_) {}
      HISTORY.backNav = false; // fin du mode retour
      return res;
    };
  }

  // --- hideCardDetail : revenir d'abord à la carte précédente, sinon à la grille
  const origHide = window.hideCardDetail;
  if (typeof origHide === 'function') {
    window.hideCardDetail = function(modId, ...rest) {
      const prev = (HISTORY[modId] || []).pop();
      if (prev) {
        const grid = document.querySelector(gridSel(modId));
        const el = grid?.querySelector(`.small-card[data-id="${prev}"]`);
        if (el) {
          HISTORY.backNav = true;                 // empêche tout "re-push"
          return window.showCardDetail(modId, el);
        }
      }
      setCurrentId(modId, null);
      return origHide.apply(this, [modId, ...rest]);
    };
  }

  // --- gotoCard : NE PUSH PLUS (c'est showCardDetail qui s'en charge)
  const origGoto = window.gotoCard;
  if (typeof origGoto === 'function') {
    window.gotoCard = function(modId, cardId) {
      HISTORY.backNav = false;
      return origGoto.apply(this, arguments);
    };
  }

  // --- change de page : purge la pile
  const origShowPage = window.showPage;
  if (typeof origShowPage === 'function') {
    window.showPage = function(pageId) {
      HISTORY.mod1 = []; HISTORY.mod2 = []; HISTORY.backNav = false;
      return origShowPage.apply(this, arguments);
    };
  }
})();

// === URL State: #p=page&type=...&q=...&card=...&pn=...
(function wireUrlState(){
  if (window.__urlStateWired) return;
  window.__urlStateWired = true;

  const getParams = () => new URLSearchParams((location.hash || '').replace(/^#/, ''));
  function setParams(upd, replace=true){
    const sp = getParams();
    Object.entries(upd || {}).forEach(([k,v]) => {
      if (v === null || v === undefined || v === '') sp.delete(k); else sp.set(k, v);
    });
    const h = '#' + sp.toString();
    if (replace) history.replaceState(null, '', h); else location.hash = h;
  }

  // Applique le hash (au changement ET au chargement)
  async function applyFromHash(){
    const sp = getParams();
    const p  = sp.get('p') || localStorage.getItem('lastPage') || 'accueil';
    if (typeof showPage === 'function') showPage(p);

    // MOD pages : filtre/recherche/carte
    if (p === 'mod1' || p === 'mod2') {
      // filtre
      const type = sp.get('type');
      if (type) {
        const btn = document.querySelector(`#${p} .side-buttons .card-btn[data-type="${type}"]`);
        if (btn) btn.click();
      }
      // recherche
      const q = sp.get('q') || '';
      const input = document.querySelector(`#${p} .search-bar`);
      if (input) {
        input.value = q;
        // déclenche la recherche existante
        const ev = new Event('input', { bubbles:true });
        input.dispatchEvent(ev);
      }
      // carte ouverte
      const card = sp.get('card');
      if (card) {
        if (typeof gotoCard === 'function') gotoCard(p, card);
      }
    }

    // Patchnotes : détail
    if (p === 'patchnotes') {
      const pn = sp.get('pn');
      if (pn && typeof showPatchDetail === 'function') {
        try { await showPatchDetail(pn); } catch(_){}
      } else {
        if (typeof showPatchList === 'function') showPatchList();
      }
    }
  }

  // 1) Binder les interactions → MAJ du hash
  // page
  const origShowPage = window.showPage;
  if (typeof origShowPage === 'function') {
    window.showPage = function(pageId) {
      setParams({ p: pageId }, true);
      return origShowPage.apply(this, arguments);
    };
  }

  // filtre (boutons latéraux)
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#mod1 .side-buttons .card-btn[data-type], #mod2 .side-buttons .card-btn[data-type]');
    if (!btn) return;
    const page = btn.closest('.page')?.id;
    if (!page) return;
    setParams({ p: page, type: btn.getAttribute('data-type') || 'all' }, true);
  }, true);

  // recherche : n’écrit q= dans le hash QUE à la validation (Enter)
  document.addEventListener('keydown', (e) => {
    const input = e.target.closest('#mod1 .search-bar, #mod2 .search-bar');
    if (!input || e.key !== 'Enter') return;
    const page = input.closest('.page')?.id;
    if (!page) return;
    setParams({ p: page, q: input.value || '' }, true);
  }, true);

  // détail carte → garde le type courant dans l’URL
  const origShow = window.showCardDetail;
  if (typeof origShow === 'function') {
    window.showCardDetail = function(modId, el) {
      const id = el?.getAttribute('data-id') || '';
      const sp = new URLSearchParams((location.hash || '').replace(/^#/, ''));
      const type = sp.get('type') || null;
      setParams({ p: modId, card: id, type: type || undefined }, false);
      return origShow.apply(this, arguments);
    };
  }

  // détail patchnote
  const origPN = window.showPatchDetail;
  if (typeof origPN === 'function') {
    window.showPatchDetail = function(id) {
      setParams({ p:'patchnotes', pn: id }, true);
      return origPN.apply(this, arguments);
    };
  }
  const origPNList = window.showPatchList;
  if (typeof origPNList === 'function') {
    window.showPatchList = function() {
      setParams({ pn: null }, true);
      return origPNList.apply(this, arguments);
    };
  }

  // 2) Suivre les changements d’URL + au chargement
  window.addEventListener('hashchange', applyFromHash);
  window.addEventListener('DOMContentLoaded', applyFromHash);
})();

// ===== Copier le lien du détail courant (cartes / patchnotes)
(function wireCopyLinkOnce(){
  if (window.__copyLinkWired) return;
  window.__copyLinkWired = true;

  function buildDeepLink(ctx){
    const base = location.origin + location.pathname;
    if (ctx === 'patchnotes') {
      const id = document.querySelector('#patchnotes .card-detail')?.getAttribute('data-current-patch-id');
      return base + (id ? `#p=patchnotes&pn=${encodeURIComponent(id)}` : '#p=patchnotes');
    }
    if (ctx === 'mod1' || ctx === 'mod2') {
      const id = document.querySelector(`#${ctx} .card-detail`)?.getAttribute('data-current-card-id');
      return base + (id ? `#p=${ctx}&card=${encodeURIComponent(id)}` : `#p=${ctx}`);
    }
    return base + (location.hash || '');
  }

  document.addEventListener('click', async (e) => {
    const btn = e.target.closest('.link-copy-btn');
    if (!btn) return;
    e.preventDefault();

    const ctx = btn.getAttribute('data-context') || btn.closest('.page')?.id || '';
    const url = buildDeepLink(ctx);

    try {
      await navigator.clipboard.writeText(url);
      // petit feedback visuel
      const old = btn.textContent;
      btn.textContent = '✅ Lien copié';
      setTimeout(()=> btn.textContent = old, 1200);
    } catch {
      // Fallback si le navigateur bloque le presse-papiers (HTTP, file://, etc.)
      try { window.prompt('Copie manuelle :', url); } catch {}
    }
  }, true);
})();

// ——— Module Nouveautés / Carrousel auto (avec flèches) ———
(function () {
  var MAX_SLIDES  = 10;
  var AUTOPLAY_MS = 4000;

  // Images par défaut par mod (laisse "" si tu n’en veux pas)
  var MOD_IMAGES = {
    acatar:   "images/ui/new_logo_acatar.png",   // ex: "assets/mods/acatar.png"
    chaosium: "images/ui/chaosium_image.png",    // ex: "assets/mods/chaosium.png"
    maintenance: "images/ui/maintenance_warning.jpg" // ⬅ ton image de maintenance
  };

  var STATE = { items: [], idx: 0, timer: null };

  function clsStage(s){ s=String(s||'').toLowerCase(); if(s==='release')return'release'; if(s==='beta')return'beta'; return'dev'; }
  function t(lang,key,def){ try{var pack=window.translations&&window.translations[lang]; return (pack&&pack[key])||def;}catch{return def;} }
  function pickLoc(it,lang){
    var title=(lang==='fr'?(it.title_fr||it.title_en):(it.title_en||it.title_fr))||"";
    var summary=(lang==='fr'?(it.summary_fr||it.summary_en):(it.summary_en||it.summary_fr))||"";
    return { title:String(title), summary:String(summary) };
  }
  function shouldHide(it){ if(!it||!it.until)return false; var d=Date.parse(it.until); return !isNaN(d)&&d<Date.now(); }

  // ——— remplace TOUTE la fonction fromPatch du module "Nouveautés / Carrousel" ———
function fromPatch(p, pinned){
  var mod = String(p.mod || '').toLowerCase();

  // Stage calculé : priorité aux flags beta/alpha, sinon stage|type, sinon "dev"
  function stageFromPatch(pp){
    if (pp && pp.beta === true)  return 'beta';
    if (pp && pp.alpha === true) return 'alpha';
    var s = String(pp && (pp.stage || pp.type) || '').toLowerCase();
    if (s === 'beta' || s === 'bêta')   return 'beta';
    if (s === 'alpha')                  return 'alpha';
    if (s === 'release' || s === 'stable' || s === 'final') return 'release';
    return 'dev';
  }

  // — extraire des features depuis sections_fr/en —
  function extract(lang){
    var key  = (lang === 'fr') ? 'sections_fr' : 'sections_en';
    var secs = Array.isArray(p[key]) ? p[key] : [];
    if (!secs.length) return [];
    // priorité à AJOUT/ADD sinon 1ère section avec items
    var prefIdx = secs.findIndex(s =>
      String(s.title || '').toUpperCase().startsWith(lang === 'fr' ? 'AJOUT' : 'ADD')
    );
    var s = secs[prefIdx >= 0 ? prefIdx : secs.findIndex(x => Array.isArray(x.items) && x.items.length)];
    s = s || secs[0];
    var items = Array.isArray(s?.items) ? s.items : [];
    return items
      .filter(v => typeof v === 'string')
      .map(v => v.trim())
      .filter(Boolean)
      .slice(0, 5);
  }

  return {
    custom:     false,
    pinned:     !!pinned,
    date:       p.date || '',
    title_fr:   p.title_fr || p.title || '',
    title_en:   p.title_en || p.title || '',
    summary_fr: p.summary_fr || p.summary || '',
    summary_en: p.summary_en || p.summary || '',
    stage:      stageFromPatch(p),                           // ← badge correct (DEV/BETA/ALPHA/RELEASE)
    patch_id:   String(p.id || ''),
    link:       '#p=patchnotes&pn=' + encodeURIComponent(p.id || ''),
    mod:        mod,
    image:      p.image || MOD_IMAGES[mod] || '',           // image mod si dispo
    features_fr: extract('fr'),
    features_en: extract('en')
  };
}

  // remplace l'ancienne version
  function pickFeatures(it, lang){
    var arr = (lang === 'fr') ? it.features_fr : it.features_en;
    return Array.isArray(arr) ? arr.filter(Boolean) : [];
  }

  function sortNews(arr){
    return (arr||[]).slice().sort(function(a,b){
      var ap=a&&a.pinned?1:0, bp=b&&b.pinned?1:0; if(ap!==bp)return bp-ap;
      return (b.date||'').localeCompare(a.date||'');
    }).slice(0,MAX_SLIDES);
  }

  async function loadAll(){
    var NEWS_URL=new URL('news.json',document.baseURI).toString();
    var PATCH_URL=new URL('patchnotes.json',document.baseURI).toString();
    function bust(u){return u+(u.indexOf('?')>=0?'&':'?')+'t='+Date.now();}

    var rawNews=[];
    try{ var rN=await fetch(bust(NEWS_URL),{cache:'no-store'}); if(!rN.ok)throw 0; rawNews=await rN.json(); }catch{ rawNews=[]; }

    var patchMap=new Map();
    try{ var rP=await fetch(bust(PATCH_URL),{cache:'no-store'}); if(rP.ok){ var arr=await rP.json(); (Array.isArray(arr)?arr:[]).forEach(function(p){ if(p&&p.id)patchMap.set(String(p.id),p); }); } }catch{}

    var resolved=[];
    (Array.isArray(rawNews)?rawNews:[]).forEach(function(n){
      if(!n)return;
      // — custom —
    // — custom —
    if (n.custom) {
      const modKeyRaw = String(n.mod || '').toLowerCase();
      const isMaint   = (n.type === 'maintenance') || (modKeyRaw === 'maintenance');

      // image: priorité à n.image, sinon fallback maintenance, sinon fallback par mod
      const img =
        n.image ||
        (isMaint ? (MOD_IMAGES.maintenance || '') : '') ||
        (MOD_IMAGES[modKeyRaw] || '');

      // ⚠️ maintenance → PAS DE BOUTON (on vide le lien)
      const link = isMaint ? '' : (n.link || '');

      resolved.push({
        custom: true,
        pinned: !!n.pinned,
        date: n.date || '',
        title_fr: n.title_fr || '',
        title_en: n.title_en || '',
        summary_fr: n.summary_fr || '',
        summary_en: n.summary_en || '',
        stage: n.stage || 'dev',
        patch_id: '',
        link,                                  // ← vide si maintenance → pas de bouton
        mod: isMaint ? 'maintenance' : modKeyRaw,
        image: img
      });
      return;
    }
      var p=n.id?patchMap.get(String(n.id)):null;
      if(p) resolved.push(fromPatch(p,!!n.pinned));
    });

    STATE.items=sortNews(resolved);
  }

  function buildDetailHTML(it, lang){
    function defaultHint(l){
      return (l==='en')
        ? 'Some highlights — press “Learn more” to see details.'
        : 'Quelques nouveautés — appuyez sur « En savoir plus » pour voir le détail.';
    }

    const titleRaw = (lang==='fr' ? (it.title_fr||it.title_en) : (it.title_en||it.title_fr)) || '';
    const title    = String(titleRaw).trim();

    const summary  = ((lang==='fr' ? (it.summary_fr||it.summary_en) : (it.summary_en||it.summary_fr)) || '').trim();
    const summaryToShow = summary || defaultHint(lang);

    const modLabel = it.mod==='chaosium' ? (translations?.[lang]?.chaosium || 'Chaosium')
                  : it.mod==='acatar'   ? (translations?.[lang]?.acatar   || 'Acatar')
                  : (it.mod==='maintenance' ? (lang==='fr'?'Maintenance':'Maintenance') : '');

    // version : prend it.version si dispo, sinon essaie depuis le titre
    let version = it.version ? String(it.version) : '';
    if (!version) {
      const m = /\bv?(\d+(?:\.\d+){0,3})\b/i.exec(title);
      if (m) version = 'v' + m[1];
    }

    // si le titre contient déjà le mod et/ou la version, on le cache pour éviter le doublon
    const tL = title.toLowerCase();
    const hasModInTitle = modLabel ? tL.includes(modLabel.toLowerCase()) : false;
    const hasVerInTitle = version ? tL.includes(version.toLowerCase().replace(/^v/,'v')) : false;
    const showTitle = !(hasModInTitle || hasVerInTitle); // -> masque le titre s'il fait doublon

    const metaParts = [];
    if (modLabel) metaParts.push('<span class="news-meta">'+modLabel+'</span>');
    if (it.date)   metaParts.push('<span class="news-meta">'+it.date+'</span>');
    const meta = metaParts.join(' ');

    const badge = it.stage ? '<span class="stage-badge '+clsStage(it.stage)+'">'+String(it.stage).toUpperCase()+'</span>' : '';

    const hasImg = !!it.image;
    const visual = hasImg ? '<div class="visual"><img src="'+it.image+'" alt=""></div>' : '';

    const feats = pickFeatures(it, lang).slice(0, 5);
    const featsHTML = feats.length ? '<ul class="news-features">' + feats.map(li => '<li>'+li+'</li>').join('') + '</ul>' : '';

    const isMaintenance =
      it.mod === 'maintenance' || it.type === 'maintenance' || /maintenance/i.test(title);

    const moreLbl = (lang==='fr' ? 'En savoir plus' : 'Learn more');
    const btnHTML = (!isMaintenance && it.link)
      ? '<a href="'+it.link+'" class="card-btn wiki news-open">'+moreLbl+'</a>'
      : '';

    return ''
      + (badge || meta ? '<div>'+badge+(meta ? ' <span style="opacity:.85">'+meta+'</span>' : '')+'</div>' : '')
      + (modLabel || version ? '<div class="modver">'+(modLabel||'')+(version ? ' — <span class="ver">'+version+'</span>' : '')+'</div>' : '')
      + (showTitle && title ? '<div class="title">'+title+'</div>' : '')
      + '<div class="detail-body'+(hasImg?' has-visual':'')+'">'
      +    (hasImg ? visual : '')
      +    '<div class="body-col"'+(isMaintenance?' data-maint="1"':'')+'>'
      +       (summaryToShow ? '<div class="summary">'+summaryToShow+'</div>' : '')
      +       featsHTML
      +       (btnHTML ? '<div class="actions">'+btnHTML+'</div>' : '')
      +    '</div>'
      + '</div>';
  }

  function renderDots(root){
    var dots=root.querySelector('.news-dots'); if(!dots)return;
    var html=''; for(var i=0;i<STATE.items.length;i++){ html+='<button class="dot'+(i===STATE.idx?' active':'')+'" data-idx="'+i+'" aria-label="Slide '+(i+1)+'"></button>'; }
    dots.innerHTML=html;
  }

  function renderDetail(root){
    var lang=localStorage.getItem('siteLanguage')||'fr';
    var it=STATE.items[STATE.idx];
    var box=root.querySelector('.news-detail'); if(!box)return;
    box.innerHTML=it?buildDetailHTML(it,lang):'';
    // déclenche la transition (reset + reflow + ajout de classe)
    box.classList.remove('fade-in');
    void box.offsetWidth; // force le reflow
    box.classList.add('fade-in');

    // deep-link : #p=patchnotes&pn=<id> → ton routeur doit ouvrir le patch
    var btn=box.querySelector('.news-open');
    if(btn && it && it.patch_id){
      // rien à faire : on laisse le hash faire (applyFromHash/showPage côté app)
    }
  }

  function goTo(root, idx){
    if(!STATE.items.length) return;
    STATE.idx = (idx + STATE.items.length) % STATE.items.length;
    renderDetail(root);
    renderDots(root);
  }

  function startAutoplay(root){
    stopAutoplay();
    if(STATE.items.length<=1) return;
    STATE.timer = setInterval(function(){ goTo(root, STATE.idx+1); }, AUTOPLAY_MS);
  }
  function stopAutoplay(){ if(STATE.timer){ clearInterval(STATE.timer); STATE.timer=null; } }

    // Remplacer TOUTE la fonction init() par celle-ci
  async function init() {
    const root = document.getElementById('home-featured');
    if (!root) return;

    // entête + flèches
    root.innerHTML = `
      <div class="news-head">
        <h3 class="news-title"></h3>
        <div class="news-dots" aria-label="Pagination"></div>
      </div>
      <div class="news-viewport">
        <button class="news-nav prev" aria-label="Prev">‹</button>
        <div class="news-detail"></div>
        <button class="news-nav next" aria-label="Next">›</button>
      </div>
    `;
    root.style.display = '';

    // fonction utilisée lors d’un changement de langue
    window.__refreshNewsLang = function(){
      const lang = ETAT.langue || 'fr';
      const h = root.querySelector('.news-title');
      if (h) h.textContent = (translations?.[lang]?.news_title) || (lang==='en' ? "What's new" : 'Nouveautés');
      // re-render le slide courant avec le bon texte
      renderDetail(root);
      renderDots(root);
      // accessibilité
      root.querySelector('.news-nav.prev')?.setAttribute('aria-label', lang==='fr'?'Précédent':'Previous');
      root.querySelector('.news-nav.next')?.setAttribute('aria-label', lang==='fr'?'Suivant':'Next');
    };

    try { await loadAll(); } catch(e){ console.warn(e); }

    // premier rendu (met aussi le titre)
    window.__refreshNewsLang();

    if (!STATE.items.length) {
      const lang = ETAT.langue || 'fr';
      root.querySelector('.news-detail').innerHTML =
        `<div class="summary" style="opacity:.9">${lang==='fr'?'Aucune nouveauté pour le moment.':'No news for now.'}</div>`;
      renderDots(root);
      return;
    }

    goTo(root, 0);
    startAutoplay(root);

    // interactions
    root.addEventListener('click', (e) => {
      const dot  = e.target.closest?.('.dot');
      const prev = e.target.closest?.('.news-nav.prev');
      const next = e.target.closest?.('.news-nav.next');
      if (dot){ e.preventDefault(); stopAutoplay(); goTo(root, +dot.dataset.idx||0); startAutoplay(root); }
      if (prev){ e.preventDefault(); stopAutoplay(); goTo(root, STATE.idx-1); startAutoplay(root); }
      if (next){ e.preventDefault(); stopAutoplay(); goTo(root, STATE.idx+1); startAutoplay(root); }
    });
    root.addEventListener('mouseenter', () => stopAutoplay());
    root.addEventListener('mouseleave', () => startAutoplay(root));
  }

  document.addEventListener('DOMContentLoaded', init);
})();

