const translations = {
  fr: {
    accueil: "Accueil",
    language: "Langue",
    news_title: "Nouveaut√©s",
    site_title: "Wiki des Mods de Phax709",
    acatar: "Acatar",
    chaosium: "Chaosium",
    sirens: "Phax Sirens",
    home_acatar_desc: "Un mod qui facilite les nouveaux joueurs dans Minecraft ainsi pour les joueurs avec plus d'exp√©rience des fonctionnalit√©s nouvelles.",
    home_chaosium_desc: "Un mod fait pour les joueurs tr√®s exp√©riment√©s et qui veulent du challenge et de la difficult√© ! D'o√π son nom !",
    home_phaxsirens_desc: "Un mod de sir√®nes et de lampes configurables avec plusieurs couleurs et effets.",
    home_comingsoon_desc: "Un nouveau mod est actuellement en pr√©paration. Plus d‚Äôinformations seront partag√©es prochainement.",
    patchnotes: "Patch Notes",
    settings: "Param√®tres",
    credits: "Cr√©dits",
    back: "Retour",
    theme_label: "Th√®me :",
    font_label: "Taille du texte :",
    dark: "Sombre",
    light: "Clair",
    blue: "Bleu",
    font_normal: "Normale",
    font_large: "Grand",
    font_xlarge: "Tr√®s grand",
    search_placeholder: "Rechercher‚Ä¶",
    layout_label: "Affichage",
    layout_2x3: "2 colonnes √ó 3 rang√©es",
    layout_3x2: "3 colonnes √ó 2 rang√©es",
    home_welcome_title: "Bienvenue",
    home_welcome_p1_a: "Bienvenue sur le wiki des mods Minecraft cr√©√© par",
    home_welcome_p2: "S√©lectionnez un mod dans le menu en haut pour en savoir plus !",
    all_mc_versions: "Toutes les versions Minecraft",
    sort_new_to_old: "Plus r√©cent ‚Üí plus ancien",
    sort_old_to_new: "Plus ancien ‚Üí plus r√©cent",
    tout: "Tout",
    blocs: "Blocs",
    items: "Objets",
    mobs: "Mobs",
    nature: "Nature",
    structure: "Structures",
    minerai: "Minerais",
    craft: "Craft / Recette", //√† choisir mais je peux aussi mettre Recette
    filter_label: "Filtrer :",
    patch_acatar: "Patchnotes Acatar",
    patch_chaosium: "Patchnotes Chaosium",
    patch_history: "Historique des mises √† jour",
    build_label: "Type",
    build_all: "Tous",
    build_release: "Release",
    build_beta: "Beta",
    build_alpha: "Alpha",
    prochaine_maj: "Prochaine mise √† jour",
    pourcentage_complete: "{percent}% compl√©t√©",
    next_update: "Prochaine mise √† jour",
    status: "Statut",
    mod_status_title: "Statut du mod",
    progress_label: "Progression",
    planned_features: "Fonctionnalit√©s pr√©vues",
    planned_update: "Mise √† jour pr√©vue pour le ",
    help_title: "Nous aider",
    help_desc: "Signalez un bug ou proposez une id√©e pour am√©liorer les mods.",
    report_bug: "Signaler un bug",
    suggest_idea: "Proposer une suggestion",
    satisfaction_survey: "Enqu√™te de satisfaction",
    help_site_title: "Am√©liorer le site",
    help_site_desc: "Donnez votre avis sur l‚Äôergonomie, la vitesse, les contenus, les couleurs, et plus encore.",
    site_survey_btn: "Enqu√™te de satisfaction du site",
    langue_fr: "Fran√ßais",
    langue_en: "English",
    credits_title: "Cr√©dits",
    credits_intro: "Cette page liste les droits d‚Äôauteur et les attributions des √©l√©ments utilis√©s dans ce wiki.",
    assets_mojang_title: "Attribution ‚Äî Mojang / Minecraft",
    assets_mojang_text: "Minecraft est une marque d√©pos√©e de Mojang AB. Certaines textures (ex. lingots, blocs) utilis√©es sur ce site et/ou dans les mods sont des d√©riv√©s des textures de Minecraft (recolorations/variantes). Ce site et ces mods ne sont ni affili√©s, ni approuv√©s par Mojang AB. Aucun fichier de jeu original n‚Äôest redistribu√©. ‚ö†Ô∏è Cette attribution s‚Äôapplique √† toutes les images du wiki qui int√®grent des textures d√©riv√©es ou historiques de Minecraft, y compris les captures de recettes, les aper√ßus de blocs et autres illustrations. Ces visuels sont pr√©sent√©s √† titre d‚Äôexemple uniquement.",
    your_textures_title: "Textures & images originales",
    your_textures_text: "Certaines textures et images de ce wiki et/ou de mes mods sont des cr√©ations originales de Phax709. Toute r√©utilisation, redistribution ou int√©gration dans un autre projet (site, mod, resource pack, vid√©o, etc.) n√©cessite mon autorisation pr√©alable. Merci de me contacter sur Discord (lien en bas de page) pour obtenir l‚Äôaccord.",
    third_party_title: "√âl√©ments tiers",
    third_party_discord: "Logo Discord ¬© Discord",
    credit_freepik_urgent: "Illustration utilis√©e pour les messages urgents ‚Äî",
    credit_freepik_maintenance: "Illustration utilis√©e pour la maintenance et les alertes ‚Äî",
    credit_freepik_comingsoon: "Illustration utilis√©e pour le mod en pr√©paration ‚Äî",
    site_stack_title: "Stack du site",
    site_stack_host: "H√©bergement : GitHub Pages",
    site_stack_code: "Code front : HTML / CSS / JavaScript (vanilla) / JSON",
    credits_contact: "Attribution manquante ou question d‚Äôutilisation ? Contactez-moi sur le serveur Discord (lien en bas de page).",
    mods_credits_title: "Cr√©dits li√©s aux mods",
    mods_credits_text: "Sauf mention contraire, le code des mods, les assets non issus de Minecraft (textures, logos, images) et la documentation sont cr√©√©s par Phax709. Les √©l√©ments d√©riv√©s de Minecraft appartiennent √† Mojang AB (voir l‚Äôattribution ci-dessus).",
    license_title: "Licence",
    license_intro: "Sauf mention contraire, le contenu de ce site (texte, mises en page, images originales) est sous licence CC BY-NC-ND 4.0 ‚Äî ¬© 2025-2026 Phax709.",
    license_point_1: "Redistribution non commerciale autoris√©e avec cr√©dit ‚ÄúPhax709‚Äù et lien vers ce site.",
    license_point_2: "Aucune modification ni re-upload des fichiers.",
    license_point_3: "Vid√©os YouTube / streams Twitch mon√©tis√©s autoris√©s : cr√©dit + lien, sans h√©berger les fichiers.",
    license_point_4: "Modpacks / rehosts interdits sans autorisation √©crite.",
    home_coming_soon_button: "üöß En d√©veloppement"

  },
  en: {
    accueil: "Home",
    language: "Language",
    news_title: "What's new",
    site_title: "Phax709 Mods Wiki",
    acatar: "Acatar",
    chaosium: "Chaosium",
    sirens: "Phax Sirens",
    home_acatar_desc: "A mod that facilitates new players in Minecraft as well as for players with more experience of the new features.",
    home_chaosium_desc: "A mod made for very experienced players who want challenge and difficulty! Hence the name!",
    home_phaxsirens_desc: "A mod that adds configurable sirens and lights with multiple colors and effects.",
    home_comingsoon_desc: "A new mod is currently in preparation. More information will be shared soon.",
    patchnotes: "Patch Notes",
    settings: "Settings",
    credits: "Credits",
    back: "Back",
    theme_label: "Theme:",
    font_label: "Text size:",
    dark: "Dark",
    light: "Light",
    blue: "Blue",
    font_normal: "Normal",
    font_large: "Large",
    font_xlarge: "Very large",
    search_placeholder: "Search‚Ä¶",
    layout_label: "Layout",
    layout_2x3: "2 columns √ó 3 rows",
    layout_3x2: "3 columns √ó 2 rows",
    home_welcome_title: "Welcome",
    home_welcome_p1_a: "Welcome to the wiki for Minecraft mods created by",
    home_welcome_p2: "Pick a mod from the top menu to learn more!",
    all_mc_versions: "All Minecraft versions",
    sort_new_to_old: "Newest ‚Üí oldest",
    sort_old_to_new: "Oldest ‚Üí newest",
    tout: "All",
    blocs: "Blocks",
    items: "Items",
    mobs: "Mobs",
    nature: "Nature",
    structure: "Structures",
    minerai: "Ores",
    craft: "Craft / Recipe", //√† choisir mais je peux aussi mettre Recette
    filter_label: "Filter:",
    patch_acatar: "Acatar Patch Notes",
    patch_chaosium: "Chaosium Patch Notes",
    patch_history: "Patch History",
    build_label: "Type",
    build_all: "All",
    build_release: "Release",
    build_beta: "Beta",
    build_alpha: "Alpha",
    prochaine_maj: "Next Update",
    pourcentage_complete: "{percent}% complete",
    next_update: "Next Update",
    status: "Status",
    mod_status_title: "Mod Status",
    progress_label: "Progress",
    planned_features: "Planned features",
    planned_update: "Update planned for ",
    help_title: "Help us",
    help_desc: "Report a bug or suggest an idea to improve the mods.",
    report_bug: "Report a bug",
    suggest_idea: "Suggest an idea",
    satisfaction_survey: "Satisfaction survey",
    help_site_title: "Improve the site",
    help_site_desc: "Give your opinion about the interface, speed, content, colors, and more.",
    site_survey_btn: "Site feedback & satisfaction survey",
    langue_fr: "French",
    langue_en: "English",
    credits_title: "Credits",
    credits_intro: "This page lists copyrights and attributions for the assets used on this wiki.",
    assets_mojang_title: "Attribution ‚Äî Mojang / Minecraft",
    assets_mojang_text: "Minecraft is a trademark of Mojang AB. Some textures (e.g., ingots, blocks) used on this site and/or in the mods are derived from Minecraft textures (recolorations/variants). This site and these mods are neither affiliated with nor approved by Mojang AB. No original game files are redistributed. ‚ö†Ô∏è This attribution applies to all images on the wiki that include derived or legacy Minecraft textures, including recipe screenshots, block previews, and other illustrations. Such visuals are provided for illustrative purposes only.",
    your_textures_title: "Original textures & images",
    your_textures_text: "Some textures and images on this wiki and/or in my mods are original creations by Phax709. Any reuse, redistribution, or inclusion in another project (website, mod, resource pack, video, etc.) requires my prior permission. Please contact me on Discord (link in the footer) to request approval.",
    third_party_title: "Third-party elements",
    third_party_discord: "Discord logo ¬© Discord",
    credit_freepik_urgent: "Illustration used for urgent messages ‚Äî",
    credit_freepik_comingsoon: "Illustration used for the upcoming mod ‚Äî",
    credit_freepik_maintenance: "Illustration used for maintenance and warnings ‚Äî",
    site_stack_title: "Site stack",
    site_stack_host: "Hosting: GitHub Pages",
    site_stack_code: "Frontend: HTML / CSS / JavaScript (vanilla) / JSON",
    credits_contact: "Missing attribution or usage question? Ping me on the Discord server (link in the footer).",
    mods_credits_title: "Mod credits",
    mods_credits_text: "Unless stated otherwise, the mod code, non-Minecraft assets (textures, logos, images), and documentation are created by Phax709. Derivative elements of Minecraft remain the property of Mojang AB (see attribution above).",
    license_title: "License",
    license_intro: "Unless stated otherwise, the content of this site (text, layouts, original images) is licensed under CC BY-NC-ND 4.0 ‚Äî ¬© 2025-2026 Phax709.",
    license_point_1: "Non-commercial redistribution allowed with credit ‚ÄúPhax709‚Äù and a link to this site.",
    license_point_2: "No file modifications or re-uploads.",
    license_point_3: "Monetized YouTube/Twitch allowed for showcasing: credit + link, no file hosting.",
    license_point_4: "Modpacks / rehosts forbidden without written permission.",
    home_coming_soon_button: "üöß in development"

  }
};

/********************
 * CONSTANTES & √âTAT
 ********************/
const ETAT = {
  langue: localStorage.getItem('siteLanguage') || 'fr',
  theme: localStorage.getItem('siteTheme') || 'theme-clair', // "theme-clair" | "theme-sombre"
  fontSize: localStorage.getItem('siteFont') || 'font-normal', // "font-normal" | "font-grand" | "font-tres-grand"
};

const SELECTEURS = {
  // Header
  settingsMenu: '#settingsMenu',
  settingsToggle: '#settingsToggle',
  settingsPanel: '#settingsPanel',
  langSelector: '.lang-selector',
  langBtn: '#currentLangBtn',
  langDropdown: '#langDropdown',
  langFlag: '#currentLangFlag',

  // Pages & navigation
  page: '.page',
  navLiens: '.bandeau nav a',

  // Patchnotes
  patchList: '#patchnotes .patch-list',

  // Cartes
  mod1Grid: '#mod1 .cards-grid',
  mod2Grid: '#mod2 .cards-grid',
};

const CARD_SOURCES = {
  mod1: 'cards/cards_mod1.json',
  mod2: 'cards/cards_mod2.json',
};

const _cache = {
  cartes: {},
  patchnotes: null,
};


/********************
 * OUTILS DOM
 ********************/
const $ = (sel, root = document) => root.querySelector(sel);
const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));

function show(el) { if (el) el.style.display = 'block'; }
function hide(el) { if (el) el.style.display = 'none'; }
function addClass(el, c) { if (el) el.classList.add(c); }
function remClass(el, c) { if (el) el.classList.remove(c); }
function hasClass(el, c) { return !!(el && el.classList.contains(c)); }
// --- URL helper (hash) : √©crit p / type / card / q...
function setParams(obj, replace = false) {
  const sp = new URLSearchParams((location.hash || '').slice(1));
  Object.entries(obj || {}).forEach(([k, v]) => {
    if (v == null || v === '') sp.delete(k); else sp.set(k, v);
  });
  const next = '#' + sp.toString();
  if (replace) history.replaceState(null, '', next);
  else         history.pushState(null, '', next);
}

function syncFilterActive(modId){
  const page  = document.getElementById(modId);
  if (!page) return;
  const type  = localStorage.getItem(`${modId}:lastType`) || 'all';
  const group = page.querySelector('.side-buttons');
  if (!group) return;

  group.querySelectorAll('.card-btn').forEach(b => b.classList.remove('active'));
  (group.querySelector(`.card-btn[data-type="${type}"]`)
    || group.querySelector(`.card-btn[data-type="all"]`)
  )?.classList.add('active');
}

function markFilterActive(modId, type){
  const page  = document.getElementById(modId);
  if (!page) return;
  const group = page.querySelector('.side-buttons');
  if (!group) return;

  // cl√© finale (par d√©faut 'all')
  const key = (type && type !== 'all') ? type : 'all';

  // reset
  group.querySelectorAll('.card-btn').forEach(btn => {
    btn.classList.remove('active');
    btn.removeAttribute('aria-pressed');
  });

  // cible
  const target =
    group.querySelector(`.card-btn[data-type="${key}"]`)
    || group.querySelector(`.card-btn[data-type="all"]`);

  if (target){
    target.classList.add('active');
    target.setAttribute('aria-pressed', 'true');
  }
}

function getCardsForPage(page){
  if (!page) return [];
  const grid = page.querySelector('.cards-grid');
  // On RE-LIT toujours la liste des cartes pour √©viter le bug avec le chargement async
  return grid ? Array.from(grid.querySelectorAll('.small-card')) : [];
}

function debounce(fn, delay=120){
  let to; return (...args)=>{ clearTimeout(to); to=setTimeout(()=>fn(...args), delay); };
}


/********************
 * I18N (simple)
 ********************/
/********************
 * I18N ‚Äî applique les traductions SANS casser les menus
 ********************/
function setPageTitle(lang) {
  const wanted = (translations?.[lang]?.site_title) || translations.fr.site_title || '';

  // cible prioritairement <title id="siteTitle">
  let titleEl = document.getElementById('siteTitle') || document.querySelector('head > title');
  if (!titleEl) {
    titleEl = document.createElement('title');
    titleEl.id = 'siteTitle';
    document.head.appendChild(titleEl);
  }
  titleEl.textContent = wanted;

  // synchronise l‚ÄôAPI document.title (barre d‚Äôonglet)
  document.title = wanted;
}

function applyTranslations(lang) {
  const dict = (translations && translations[lang]) ? translations[lang] : translations.fr;

  // Remplace uniquement le texte des √©l√©ments marqu√©s data-translate
  document.querySelectorAll('[data-translate]').forEach(el => {
    const key = el.getAttribute('data-translate')?.trim();
    if (!key) return;

    let txt = dict[key];
    if (txt == null) return;

    // Placeholder {percent} optionnel si l'√©l√©ment donne une valeur
    const pct = el.getAttribute('data-percent');
    if (pct) txt = txt.replace('{percent}', pct);

    // IMPORTANT : n‚Äô√©crase pas la structure (pas d‚ÄôinnerHTML ici)
    el.textContent = txt;
  });

  // (Optionnel) Met √† jour le libell√© des options de langue si tu as un span d√©di√©
  // Exemple HTML recommand√© :
  // <button class="lang-option" data-lang="fr"><img ...><span class="lbl"></span></button>
  const frLbl = document.querySelector('.lang-option[data-lang="fr"] .lbl');
  if (frLbl) frLbl.textContent = dict.langue_fr;
  const enLbl = document.querySelector('.lang-option[data-lang="en"] .lbl');
  if (enLbl) enLbl.textContent = dict.langue_en;

  document.querySelectorAll('[data-translate-placeholder]').forEach(el=>{
  const k = el.getAttribute('data-translate-placeholder'); 
  if (translations[lang]?.[k]) el.placeholder = translations[lang][k];
});
document.querySelectorAll('[data-translate-title]').forEach(el=>{
  const k = el.getAttribute('data-translate-title'); 
  if (translations[lang]?.[k]) el.title = translations[lang][k];
});

}

function setLanguage(lang) {
  const chosen = lang || 'fr';
  ETAT.langue = chosen;
  localStorage.setItem('siteLanguage', chosen);

  document.documentElement.setAttribute('lang', chosen);

  const flag = document.querySelector('#currentLangFlag');
  if (flag) flag.src = (chosen === 'en') ? 'images/flag-gb.png' : 'images/flag-fr.png';

  applyTranslations(chosen);
  setPageTitle(chosen); // <= ajoute cette ligne

  if (document.getElementById('patchnotes')?.style.display !== 'none') renderPatchList();
  if (document.getElementById('mod1')?.style.display !== 'none') ensureCards('mod1');
  if (document.getElementById('mod2')?.style.display !== 'none') ensureCards('mod2');

  const st1 = document.querySelector('#mod1 .update-panel');
  if (st1 && st1.style.display !== 'none') showStatus('mod1', true);
  const st2 = document.querySelector('#mod2 .update-panel');
  if (st2 && st2.style.display !== 'none') showStatus('mod2', true);
  if (window.__refreshHomeChips) window.__refreshHomeChips();
  ensureStatusTitle();
  if (window.__refreshNewsLang) window.__refreshNewsLang();

  // Re-rendre le d√©tail de carte si une est actuellement affich√©e
  ['mod1', 'mod2'].forEach(modId => {
    const page = document.getElementById(modId);
    if (page) {
      const detail = page.querySelector('.card-detail');
      const zone = page.querySelector('.detail-content');
      const cardId = detail?.getAttribute('data-current-card-id');
      if (detail && zone && cardId && detail.style.display !== 'none') {
        zone.innerHTML = renderCardDetailContent(modId, cardId, chosen);
      }
    }
  });
}



/********************
 * TH√àME & TAILLE DE POLICE
 ********************/
function appliquerThemeEtPolice() {
  document.body.classList.remove('theme-clair', 'theme-sombre', 'theme-bleu', 'font-normal', 'font-grand', 'font-tres-grand');
  document.body.classList.add(ETAT.theme, ETAT.fontSize);
}

function initThemeEtPolice() {
  // Applique l‚Äô√©tat sauvegard√©
  appliquerThemeEtPolice();

  // Boutons (optionnels si pr√©sents dans ton HTML)
  const btnSombre = document.getElementById('themeSombre');
  const btnClair = document.getElementById('themeClair');
  const btnBleu = document.getElementById('themeBleu');
  const fontNormal = document.getElementById('fontNormal');
  const fontGrand = document.getElementById('fontGrand');
  const fontTresGrand = document.getElementById('fontTresGrand');

  if (btnSombre) btnSombre.addEventListener('click', () => {
    ETAT.theme = 'theme-sombre';
    localStorage.setItem('siteTheme', ETAT.theme);
    appliquerThemeEtPolice();
  });
  if (btnClair) btnClair.addEventListener('click', () => {
    ETAT.theme = 'theme-clair';
    localStorage.setItem('siteTheme', ETAT.theme);
    appliquerThemeEtPolice();
  });
  if (btnBleu) btnBleu.addEventListener('click', () => {
    ETAT.theme = 'theme-bleu';
    localStorage.setItem('siteTheme', ETAT.theme);
    appliquerThemeEtPolice();
  });


  if (fontNormal) fontNormal.addEventListener('click', () => {
    ETAT.fontSize = 'font-normal';
    localStorage.setItem('siteFont', ETAT.fontSize);
    appliquerThemeEtPolice();
  });
  if (fontGrand) fontGrand.addEventListener('click', () => {
    ETAT.fontSize = 'font-grand';
    localStorage.setItem('siteFont', ETAT.fontSize);
    appliquerThemeEtPolice();
  });
  if (fontTresGrand) fontTresGrand.addEventListener('click', () => {
    ETAT.fontSize = 'font-tres-grand';
    localStorage.setItem('siteFont', ETAT.fontSize);
    appliquerThemeEtPolice();
  });
}


/********************
 * MENU LANGUE
 ********************/
function initMenuLangue() {
  const langSelector = $(SELECTEURS.langSelector);
  const langBtn      = $(SELECTEURS.langBtn);
  const dropdown     = $(SELECTEURS.langDropdown);

  if (!langSelector || !langBtn || !dropdown) return;

  // Drapeau au chargement
  setLanguage(ETAT.langue);

  // Un SEUL handler pour ouvrir/fermer (√©tat contr√¥l√©)
  langBtn.addEventListener('click', (e) => {
    e.stopPropagation();
    // fermer param√®tres avant
    remClass($(SELECTEURS.settingsMenu), 'open');
    // toggle explicite
    if (hasClass(langSelector, 'open')) remClass(langSelector, 'open'); else addClass(langSelector, 'open');
  });

  // Choix langue
  dropdown.querySelectorAll('.lang-option').forEach(opt => {
    opt.addEventListener('click', (e) => {
      e.stopPropagation();
      const lang = opt.getAttribute('data-lang') || 'fr';
      setLanguage(lang);
      remClass(langSelector, 'open');
    });
  });

  // Emp√™che la fermeture imm√©diate si clic √† l‚Äôint√©rieur
  langSelector.addEventListener('click', (e) => e.stopPropagation());
}


/********************
 * MENU PARAM√àTRES (‚öô)
 ********************/
function initMenuParametres() {
  const settingsMenu   = $(SELECTEURS.settingsMenu);
  const settingsToggle = $(SELECTEURS.settingsToggle);
  const langSelector   = $(SELECTEURS.langSelector);

  if (!settingsMenu || !settingsToggle) return;

  settingsToggle.addEventListener('click', (e) => {
    e.stopPropagation();
    // Fermer langue avant
    remClass(langSelector, 'open');
    // Toggle contr√¥l√©
    if (hasClass(settingsMenu, 'open')) remClass(settingsMenu, 'open'); else addClass(settingsMenu, 'open');
  });

  // Emp√™che fermeture sur clic interne
  settingsMenu.addEventListener('click', (e) => e.stopPropagation());

  // Clic ailleurs ‚Üí tout fermer
  document.addEventListener('click', () => {
    remClass(langSelector, 'open');
    remClass(settingsMenu, 'open');
  });
}


/********************
 * NAVIGATION PAGES
 ********************/
async function showPage(pageId) {
  // 1) masquer toutes les pages
  document.querySelectorAll('.page').forEach(p => p.style.display = 'none');

  // 2) afficher la page demand√©e
  const page = document.getElementById(pageId);
  if (page) page.style.display = 'block';

  // 3) nav actif (header + drawer mobile)
  document.querySelectorAll('.bandeau nav a').forEach(a => a.classList.remove('active'));
  const headerNavId = (pageId === 'credits') ? 'nav-accueil' : ('nav-' + pageId);
  document.getElementById(headerNavId)?.classList.add('active');

  document.querySelectorAll('#mobileDrawer .drawer-link').forEach(a => a.classList.remove('active'));
  document.querySelector(`#mobileDrawer .drawer-link[data-page="${pageId}"]`)?.classList.add('active');

  // 4) √©tat m√©moris√©
  try { localStorage.setItem('lastPage', pageId); } catch {}

  // G√©rer la barre de statuts (visible uniquement sur accueil)
  const bar  = document.getElementById('home-status');
  const rail = document.getElementById('statusRail');
  if (bar)  bar.style.display  = (pageId === 'accueil' ? 'flex'  : 'none');
  if (rail) rail.style.display = (pageId === 'accueil' ? 'block' : 'none');
  if (pageId === 'accueil') {
    if (typeof ensureStatusTitle === 'function') ensureStatusTitle();
    if (window.__refreshHomeChips) window.__refreshHomeChips();
  }

  // 5) √©l√©ments contextuels
  const grid   = page?.querySelector('.cards-grid');
  const list   = page?.querySelector('.patch-list');
  const detail = page?.querySelector('.card-detail');
  const status = page?.querySelector('.update-panel');
  if (status) status.style.display = 'none';
  if (detail) detail.style.display = 'none';

  // --- lecture des param√®tres URL (ex: #p=mod1&type=minerai)
  const sp = new URLSearchParams((location.hash || '').slice(1));
  const urlType = sp.get('type'); // null, 'all' ou une cat√©gorie
  const urlView = sp.get('view'); // 'status' ou null

  // 6) pages de mods : charger au besoin + restaurer vue & filtre
  if (pageId === 'mod1' || pageId === 'mod2') {
    // Si l'URL demande la vue "status", ne pas afficher la grille
    if (urlView === 'status') {
      if (grid) grid.style.setProperty('display', 'none', 'important');
      if (typeof showStatus === 'function') await showStatus(pageId);
      try { localStorage.setItem(`${pageId}:lastView`, 'status'); } catch {}
      return; // Sortir de la fonction, pas besoin de charger les cartes
    }

    if (grid) grid.style.display = 'grid';
    
    // ‚úÖ ATTENDRE que les cartes soient charg√©es avant de filtrer
    if (pageId === 'mod1' && typeof ensureCards === 'function') await ensureCards('mod1');
    if (pageId === 'mod2' && typeof ensureCards === 'function') await ensureCards('mod2');

    const savedType = localStorage.getItem(`${pageId}:lastType`) || 'all';
    const lastView  = localStorage.getItem(`${pageId}:lastView`) || 'grid';

    // Priorit√© au filtre (URL ou m√©moris√© ‚â† all) ‚Üí on force la grille
    const effectiveType = (urlType !== null ? urlType : savedType);
    const forceGrid = (urlType !== null) || (effectiveType && effectiveType !== 'all');

    if (forceGrid) {
      try { localStorage.setItem(`${pageId}:lastView`, 'grid'); } catch {}
      if (typeof filterCategory === 'function') filterCategory(pageId, effectiveType || 'all');
      if (typeof markFilterActive === 'function') markFilterActive(pageId, effectiveType || 'all');
    } else if (lastView === 'status') {
      if (typeof showStatus === 'function') await showStatus(pageId);
    } else {
      if (typeof filterCategory === 'function') filterCategory(pageId, savedType);
      if (typeof markFilterActive === 'function') markFilterActive(pageId, savedType);
    }
  }

  // 7) patch notes
  if (pageId === 'patchnotes') {
    if (list)   list.style.display = 'flex';
    if (detail) detail.style.display = 'none';
    if (typeof renderPatchList === 'function') renderPatchList();
  }

  // 8) Accueil : rafra√Æchir les chips de statut
  if (pageId === 'accueil') {
    if (typeof ensureStatusTitle === 'function') ensureStatusTitle();
    if (window.__refreshHomeChips) window.__refreshHomeChips();
  }

  // 9) UX : remonter, titre, back-to-top
  window.scrollTo({ top: 0, behavior: 'smooth' });
  if (typeof setPageTitle === 'function') setPageTitle(ETAT.langue);
  if (typeof updateBackToTop === 'function') updateBackToTop(pageId);

  // 10) URL : p + filtre effectif (si ‚â† all), sans empiler l‚Äôhistorique
  if (typeof setParams === 'function') {
    let t = undefined;
    try {
      const eff = (urlType !== null ? urlType : (localStorage.getItem(`${pageId}:lastType`) || 'all'));
      if (eff && eff !== 'all') t = eff;
    } catch {}
    setParams({ p: pageId, type: t, card: undefined }, true);
  }
}

/********************
 * FILTRE & RECHERCHE ‚Äî version qui ferme Statut et r√©-affiche la grille
 ********************/
function filterCategory(pageId, category) {
  const page   = document.getElementById(pageId);
  if (!page) return;

  const grid   = page.querySelector('.cards-grid');
  const list   = page.querySelector('.patch-list');
  const detail = page.querySelector('.card-detail');
  const status = page.querySelector('.update-panel');

  if (status) status.style.setProperty('display', 'none', 'important');
  if (detail) detail.style.setProperty('display', 'none', 'important');
  if (grid)   grid.style.setProperty('display', 'grid', 'important');
  if (list)   list.style.display   = 'flex';

  // Retirer les styles inline du bouton Statut
  const statusBtn = page.querySelector('.side-buttons .update-btn');
  if (statusBtn) {
    statusBtn.style.background = '';
    statusBtn.style.color = '';
    statusBtn.style.fontWeight = '';
  }

  const key = (category && category !== 'all') ? category : 'all';

  // üî∏ On r√©utilise la NodeList mise en cache
  const cards = getCardsForPage(page);
  cards.forEach(card => {
    const show = (key === 'all') || card.classList.contains(key);
    // IMPORTANT : '' (pas 'block') pour laisser la grid g√©rer l‚Äôaffichage
    card.style.display = show ? '' : 'none';
  });

  // √âtat UI + m√©morisation + URL (une seule fois)
  const group = page.querySelector('.side-buttons');
  if (group) {
    group.querySelectorAll('.card-btn').forEach(b => b.classList.remove('active'));
    (group.querySelector(`.card-btn[data-type="${key}"]`) ||
     group.querySelector(`.card-btn[data-type="all"]`))?.classList.add('active');
  }

    // Synchronise aussi le dropdown mobile, s'il existe
  const dropdown = page.querySelector('.filter-dropdown select');
  if (dropdown) {
    dropdown.value = key;
  }

  try {
    localStorage.setItem('lastPage', pageId);
    localStorage.setItem(`${pageId}:lastView`, 'grid');
    localStorage.setItem(`${pageId}:lastType`, key);
  } catch {}

  if (typeof setParams === 'function') {
    setParams({ p: pageId, type: (key !== 'all') ? key : undefined, card: undefined }, true);
  }
}

/********************
 * RECHERCHE (cartes) ‚Äî corrige l‚Äôerreur "pageId" et force le retour √† la grille
 ********************/
function searchCards(modId, query) {
  const page   = document.getElementById(modId);
  if (!page) return;

  const grid   = page.querySelector('.cards-grid');
  const detail = page.querySelector('.card-detail');
  const status = page.querySelector('.update-panel');

  if (status) status.style.display = 'none';
  if (detail) detail.style.display = 'none';
  if (grid)   grid.style.display   = 'grid';

  const qn = normalizeText(query || '');
  const cards = getCardsForPage(page);
  cards.forEach(card => {
    const t = normalizeText(card.querySelector('h4')?.textContent || '');
    const d = normalizeText(card.querySelector('p')?.textContent  || '');
    // üî∏ '' (pas 'block') pour ne pas casser la grille
    card.style.display = (!qn || t.includes(qn) || d.includes(qn)) ? '' : 'none';
  });
}

/********************
 * PATCHNOTES
 ********************/
async function loadPatchData() {
  if (_cache.patchnotes) return _cache.patchnotes;
  const res = await fetch('patchnotes.json' + `?t=${Date.now()}`, { cache: 'no-store' });
  if (!res.ok) throw new Error('HTTP ' + res.status);
  const data = await res.json();
  _cache.patchnotes = data;
  return data;
}

// √âtat de la barre d‚Äôoutils Patchnotes
let _patchToolbarInited = false;
let _patchMc     = "";      // filtre version MC
let _patchSearch = "";      // recherche texte
let _patchSort   = "desc";  // "asc" | "desc"
let _patchStage = 'all'; // "all" | "release" | "beta" | "alpha"

// Remplit le <select> des versions MC √† partir du JSON
function populateVersionFilter(data) {
  const f = document.getElementById('patchVersionFilter');
  if (!f) return;
  const set = new Set((data || []).map(n => n.mc).filter(Boolean));
  const versions = Array.from(set).sort((a,b) => a.localeCompare(b, undefined, { numeric:true }));
  // ‚¨áÔ∏è change UNIQUEMENT cette ligne :
  f.innerHTML = `<option value="">${t('all_mc_versions')}</option>` +
                versions.map(v => `<option value="${v}">MC ${v}</option>`).join('');
}

// Branche la recherche, le filtre MC et le tri
function initPatchToolbar() {
  const q = document.getElementById('patchSearch');
  const f = document.getElementById('patchVersionFilter');
  const s = document.getElementById('patchDateSort');

  // Si la toolbar n'existe pas dans le HTML, on ne fait rien
  if (!q && !f && !s) { _patchToolbarInited = true; return; }

  if (q) q.addEventListener('input',  () => { _patchSearch = (q.value || '').trim().toLowerCase(); renderPatchList(); });
  if (f) f.addEventListener('change', () => { _patchMc = f.value; renderPatchList(); });
  if (s) s.addEventListener('change', () => { _patchSort = s.value || 'desc'; renderPatchList(); });

  _patchToolbarInited = true;
  const buildSel = document.getElementById('filter-build');
  if (buildSel) {
    buildSel.value = _patchStage;
    buildSel.addEventListener('change', () => {
      _patchStage = (buildSel.value || 'all').toLowerCase();
      renderPatchList();
    });
  }
}


function buildPatchEntryHTML(entry) {
  // Champs attendus (selon ton JSON) :
  // entry.title, entry.date, entry.mod ("acatar"|"chaosium"), entry.mc (version MC), entry.notes (array)
  const modClass = entry.mod ? entry.mod.toLowerCase() : 'acatar';
  const date = entry.date ? new Date(entry.date).toLocaleDateString(ETAT.langue === 'en' ? 'en-GB' : 'fr-FR') : '';
  const mcBadge = entry.mc ? `<span class="mc-badge">MC ${entry.mc}</span>` : '';
  const notes = Array.isArray(entry.notes) ? entry.notes.map(n => `<li>${n}</li>`).join('') : '';

  return `
    <div class="patch-entry ${modClass}">
      <div class="patch-meta">
        <h4>${entry.title || 'Patch'}</h4>
        <div class="patch-info">
          <span class="patch-date">${date}</span>
          ${mcBadge}
        </div>
      </div>
      <ul class="patch-notes">${notes}</ul>
    </div>
  `;
}

/********************
 * PATCHNOTES ‚Äî liste (comme avant)
 ********************/
async function renderPatchList() {
  const list = document.querySelector('#patchnotes .patch-list');
  if (!list) return;

  const lang = localStorage.getItem('siteLanguage') || 'fr';
  const data = await loadPatchData(); // lit patchnotes.json

  // 1) Init toolbar au premier rendu
  if (!_patchToolbarInited) {
    populateVersionFilter(data);
    initPatchToolbar();
  }

  // ===== Helpers =====
  const getMc = (n) => {
    const raw = n.mc || n.minecraft_version || n.minecraftVersion || n.minecraft || n.mc_version || n.mcVersion || "";
    return raw ? String(raw).replace(/^MC\s*/i, "") : "";
  };

  const isBeta = (n) => !!(
    n.beta === true || n.is_beta === true ||
    /beta/i.test([n.channel, n.stage, n.tag, n.version, n.title].filter(Boolean).join(' '))
  );

  // "release" | "beta" | "alpha" (fallback: release)
  const getStage = (n) => {
    const s = (n.stage || '').toString().toLowerCase();
    if (s === 'release' || s === 'beta' || s === 'alpha') return s;
    const hay = [n.channel, n.tag, n.version, n.title].filter(Boolean).join(' ').toLowerCase();
    if (isBeta(n)) return 'beta';
    if (/\balpha\b/.test(hay)) return 'alpha';
    return 'release';
  };

  // 2) Cat√©gorie active (menu gauche) : all | acatar | chaosium
  const activeBtn = document.querySelector('#patchnotes .side-buttons .card-btn.active');
  const cat = activeBtn ? (activeBtn.getAttribute('data-cat') || 'all') : 'all';

  // 3) Source + filtre cat√©gorie via "mod"
  let notes = data.filter(n => (cat === 'all' ? true : (n.mod || '').toLowerCase() === cat));

  // 4) Filtre version Minecraft
  if (_patchMc) notes = notes.filter(n => getMc(n) === _patchMc);

  // 4bis) Filtre type de build (release/beta/alpha)
  const stageFilter = (typeof _patchStage !== 'undefined' ? _patchStage : 'all');
  if (stageFilter && stageFilter !== 'all') {
    notes = notes.filter(n => getStage(n) === stageFilter);
  }

  // 5) Recherche (titre + sections) ‚Äî accent-insensible
  if (_patchSearch) {
    const qn = normalizeText(_patchSearch);
    notes = notes.filter(n => {
      const title = (lang === 'fr' ? (n.title_fr || n.title_en) : (n.title_en || n.title_fr)) || '';
      const secs  = (lang === 'fr' ? (n.sections_fr || []) : (n.sections_en || []));
      const hay   = normalizeText(title + ' ' + secs.map(s => [s.title, ...(s.items||[])] .flat().join(' ')).join(' '));
      return hay.includes(qn);
    });
  }


  // 6) Tri date (ISO yyyy-mm-dd)
  notes.sort((a,b) => {
    const da = a.date || '';
    const db = b.date || '';
    return (_patchSort === 'asc') ? da.localeCompare(db) : db.localeCompare(da);
  });

  // 7) Rendu : gauche = titre + badges, droite = date
  list.innerHTML = '';
  notes.forEach(n => {
    const modKey = (n.mod || '').toLowerCase();
    const modName =
    (modKey === 'chaosium') ? (translations?.[lang]?.chaosium || 'Chaosium') :
    (modKey === 'sirens')   ? (translations?.[lang]?.sirens   || 'Phax Sirens') :
                              (translations?.[lang]?.acatar   || 'Acatar');

    const title   = `${modName}${n.version ? ` - v${n.version}` : ''}`;
    const mc      = getMc(n);
    const stage   = getStage(n);

    const mcBadge    = mc    ? `<span class="pn-badge mc">MC ${mc}</span>` : '';
    const labelStage =
      stage === 'release' ? (translations?.[lang]?.build_release || 'Release') :
      stage === 'alpha'   ? (translations?.[lang]?.build_alpha   || 'Alpha')   :
                            (translations?.[lang]?.build_beta    || 'Beta');
    const stageBadge  = stage ? `<span class="pn-badge ${stage}">${labelStage}</span>` : '';

    const dateHtml = n.date ? `<span class="pe-date">${n.date}</span>` : '';

    const div = document.createElement('div');
    div.className = `patch-entry ${modKey}`;
    div.dataset.id = n.id;

    // pe-title (avec badges) + date √† droite
    div.innerHTML = `
      <span class="pe-title"><strong>${title}</strong> ${mcBadge} ${stageBadge}</span>
      ${dateHtml}
    `;
    div.addEventListener('click', () => showPatchDetail(n.id));
    list.appendChild(div);
  });

  // 8) Assure la bonne vue
  const detail = document.querySelector('#patchnotes .card-detail');
  if (detail) detail.style.display = 'none';
  list.style.display = 'flex';
}

/********************
 * PATCHNOTES ‚Äî d√©tail & retour
 ********************/
// === D√âTAIL PATCHNOTE : titre + badges (MC + Beta)
async function showPatchDetail(patchId) {
  if (typeof hideBackToTop === 'function') hideBackToTop();
  const list    = document.querySelector('#patchnotes .patch-list');
  const detail  = document.querySelector('#patchnotes .card-detail');
  const content = detail?.querySelector('.detail-content');
  if (!list || !detail || !content) return;
  detail.setAttribute('data-current-patch-id', String(patchId));

  const lang = localStorage.getItem('siteLanguage') || 'fr';
  const data = await loadPatchData();
  const n = (data || []).find(x => String(x.id) === String(patchId));
  if (!n) return;
  try {
  detail.setAttribute('data-current-patch-id', String(patchId));
} catch {}

  // Helpers locaux (m√™mes r√®gles que la liste)
  const getMc = (n) => {
    const raw = n.mc || n.minecraft_version || n.minecraftVersion || n.minecraft || n.mc_version || n.mcVersion || "";
    return raw ? String(raw).replace(/^MC\s*/i, "") : "";
  };
  const isBeta = (n) => !!(
    n.beta === true || n.is_beta === true ||
    /beta/i.test([n.channel, n.stage, n.tag, n.version, n.title].filter(Boolean).join(' '))
  );
  const getStage = (n) => {
    const s = (n.stage || '').toString().toLowerCase();
    if (s === 'release' || s === 'beta' || s === 'alpha') return s;
    const hay = [n.channel, n.tag, n.version, n.title].filter(Boolean).join(' ').toLowerCase();
    if (isBeta(n)) return 'beta';
    if (/\balpha\b/.test(hay)) return 'alpha';
    return 'release';
  };

  // Libell√©s mod
  const modKey  = (n.mod || '').toLowerCase();
  const modName = modKey === 'chaosium'
    ? (translations?.[lang]?.chaosium || 'Chaosium')
    : (translations?.[lang]?.acatar   || 'Acatar');

  const title = `${modName}${n.version ? ` - v${n.version}` : ''}`;
  const dateHtml = n.date ? `<div class="patch-meta">${n.date}</div>` : '';

  // Badges
  const mc = getMc(n);
  const mcBadge = mc ? `<span class="pn-badge mc">MC ${mc}</span>` : '';

  const stage = getStage(n);
  const labelStage =
    stage === 'release' ? (translations?.[lang]?.build_release || 'Release') :
    stage === 'alpha'   ? (translations?.[lang]?.build_alpha   || 'Alpha')   :
                          (translations?.[lang]?.build_beta    || 'Beta');
  const stageBadge = stage ? `<span class="pn-badge ${stage}">${labelStage}</span>` : '';

  // Sections FR/EN
  const sections = (lang === 'en') ? (n.sections_en || []) : (n.sections_fr || []);
  const sectionsHTML = sections.map(sec => `
    <div class="patchnote-section">
      <h4 class="underline">${sec.title || ''}</h4>
      <ul>${(sec.items || []).map(li => `<li>${li}</li>`).join('')}</ul>
    </div>
  `).join('');

  // Liens optionnels
  const links = Array.isArray(n.links) ? n.links : [];
  const linksHTML = links.length ? `
    <div class="patch-links" style="margin-top:10px;">
      ${links.map(L => {
        const label = (lang === 'en' ? (L.label_en || L.label_fr) : (L.label_fr || L.label_en)) || 'Link';
        return `<a class="card-btn wiki" href="${L.url}" target="_blank" rel="noopener">${label}</a>`;
      }).join(' ')}
    </div>` : '';

  // Rendu
  content.innerHTML = `
  <div class="pn-head">
    <h3>${title}</h3>
    <div class="pn-badges">
      ${mcBadge}
      ${stageBadge}
    </div>
  </div>
  ${dateHtml}
  ${sectionsHTML}
  ${linksHTML}
`;

  // bascule list/d√©tail
  list.style.display   = 'none';
  detail.style.display = 'block';
  // Rebranche le back-to-top sur la liste Patchnotes et r√©√©value l'√©tat
  updateBackToTop('patchnotes');
  const listEl = document.querySelector('#patchnotes .patch-list');
  if (listEl) setTimeout(() => listEl.dispatchEvent(new Event('scroll')), 0);

  window.scrollTo({ top: 0, behavior: 'smooth' });
}

function showPatchList() {
  const list   = document.querySelector('#patchnotes .patch-list');
  const detail = document.querySelector('#patchnotes .card-detail');
  if (!list || !detail) return;
  detail.style.display = 'none';
  list.style.display = 'flex'; // ta liste est en flex dans le CSS ‚Äúcomme avant‚Äù
  // R√©-attache le back-to-top sur la liste Patchnotes et force l'√©tat
  updateBackToTop('patchnotes');
  const listEl = document.querySelector('#patchnotes .patch-list');
  if (listEl) { requestAnimationFrame(() => listEl.dispatchEvent(new Event('scroll'))); }
}

/********************
 * D√âTAIL CARTES
 ********************/
// Helper : g√©n√®re un sprite anim√© (utilis√© par thumb ET d√©tail)
function makeSpriteHTML(sideKey, cfg, targetH, pixelated = true, maxW = null, extraCSS = '') {
  if (!cfg || !cfg.src) return '';
  cfg.frame_width  = cfg.frame_width  ?? cfg.frameWidth;
  cfg.frame_height = cfg.frame_height ?? cfg.frameHeight;
  if (!cfg.frames || !cfg.frame_width || !cfg.frame_height) return '';

  const frames = Math.max(1, cfg.frames|0);
  const dir    = (cfg.direction === 'horizontal') ? 'horizontal' : 'vertical';
  const fps    = (cfg.fps && cfg.fps > 0) ? cfg.fps : 6;

  const dispH  = Math.max(1, targetH|0);
  const ratio  = cfg.frame_width / cfg.frame_height;
  const dispW  = Math.round(dispH * ratio);

  const bgSize = (dir === 'horizontal')
    ? `${dispW * frames}px ${dispH}px`
    : `${dispW}px ${dispH * frames}px`;

  const order     = Array.isArray(cfg.order) ? cfg.order : null;
  const durations = Array.isArray(cfg.durations) ? cfg.durations : null;

  const pxCSS   = pixelated ? 'image-rendering:pixelated;' : 'image-rendering:auto;';
  const maxWcss = (maxW && maxW > 0) ? `max-width:${maxW}px;` : '';

  // Note: on ne peut pas mettre resolveAsset ici car on n'a pas modId, donc on le fait avant d'appeler
  return `
    <div class="sprite-${sideKey}" data-sprite="1"
         data-frames="${frames}" data-fps="${fps}"
         data-dir="${dir}" data-fw="${cfg.frame_width}" data-fh="${cfg.frame_height}"
         ${order ? `data-order="${order.join(',')}"` : ''}
         ${durations ? `data-durations="${durations.join(',')}"` : ''}
         style="
           width:${dispW}px;height:${dispH}px;
           background-image:url('${cfg.src}');
           background-repeat:no-repeat;
           background-position:0 0;
           background-size:${bgSize};
           ${pxCSS}${maxWcss}
           border-radius:8px;
           ${extraCSS}
         "></div>`;
}

// Rend le contenu d√©tail d'une carte √† partir de son ID et du modId
function renderCardDetailContent(modId, cardId, lang) {
  const cardsData = _cache.cartes[modId] || [];
  const c = cardsData.find(card => card.id === cardId);
  
  if (!c) {
    console.warn(`[renderCardDetailContent] Carte "${cardId}" non trouv√©e dans le cache ${modId}`, {
      cacheSize: cardsData.length,
      availableIds: cardsData.slice(0, 5).map(card => card.id)
    });
    return '<p style="color:#c62828;">‚ùå Carte non trouv√©e. Essayez de recharger la page.</p>';
  }

  lang = lang || ETAT.langue || 'fr';

  // --- Helpers
  const renderRichList = (arr) => {
    const lines = Array.isArray(arr) ? arr : [];
    if (!lines.length) return '';
    return `<ul>${
      lines.map(raw => {
        const txt = (raw ?? '').toString();
        if (!txt.trim()) return `<li class="spacer" style="list-style:none;height:.35rem;"></li>`;
        if (/^\s*\*/.test(txt)) {
          const label = txt.replace(/^\s*\*\s*/, '');
          return `<li class="subhead" style="list-style:none;margin:8px 0 4px;text-indent:-1.15em;padding-left:1.15em;"><strong>${label}</strong></li>`;
        }
        return `<li>${txt}</li>`;
      }).join('')
    }</ul>`;
  };

  const title = (lang === 'en') ? (c.title_en || c.title_fr || '') : (c.title_fr || c.title_en || '');
  const desc  = (lang === 'en') ? (c.description_en || c.description_fr || '') : (c.description_fr || c.description_en || '');

  // ---------- SOURCES d'images gauche/droite (comme dans renderCards) ----------
  // GAUCHE
  const leftPool = Array.isArray(c.image_left_pool) ? c.image_left_pool : [];
  const leftCandidates = leftPool.length ? leftPool : (c.image_left ? [c.image_left] : []);
  let leftIdx = 0;
  if (leftCandidates.length > 1) {
    const mode = c.left_select || 'sticky';
    if (mode === 'daily') {
      const day = Math.floor(Date.now() / 86400000);
      leftIdx = day % leftCandidates.length;
    } else if (mode === 'random') {
      leftIdx = Math.floor(Math.random() * leftCandidates.length);
    } else {
      const key = 'leftChoice:' + (c.id || 'card');
      const saved = localStorage.getItem(key);
      if (saved !== null && !isNaN(+saved)) leftIdx = (+saved) % leftCandidates.length;
      else { leftIdx = Math.floor(Math.random() * leftCandidates.length); try{localStorage.setItem(key, String(leftIdx));}catch(_){} }
    }
  }
  const leftUrls = leftCandidates.map(raw => resolveAsset(modId, raw));
  const leftSrc  = leftUrls[leftIdx] || '';

  // DROITE
  const rightPool = Array.isArray(c.image_right_pool) ? c.image_right_pool : (Array.isArray(c.image_pool) ? c.image_pool : []);
  const rightCandidates = rightPool.length ? rightPool : (c.image ? [c.image] : []);
  let rightIdx = 0;
  if (rightCandidates.length > 1) {
    const mode = c.right_select || 'sticky';
    if (mode === 'daily') {
      const day = Math.floor(Date.now() / 86400000);
      rightIdx = day % rightCandidates.length;
    } else if (mode === 'random') {
      rightIdx = Math.floor(Math.random() * rightCandidates.length);
    } else {
      const key = 'rightChoice:' + (c.id || 'card');
      const saved = localStorage.getItem(key);
      if (saved !== null && !isNaN(+saved)) rightIdx = (+saved) % rightCandidates.length;
      else { rightIdx = Math.floor(Math.random() * rightCandidates.length); try{localStorage.setItem(key, String(rightIdx));}catch(_){} }
    }
  }
  const rightUrls = rightCandidates.map(raw => resolveAsset(modId, raw));
  const rightSrc  = rightUrls[rightIdx] || '';

  const leftRotateMs =
    (typeof c.left_rotate_ms === 'number' && c.left_rotate_ms > 0) ? Math.round(c.left_rotate_ms)
    : (typeof c.left_rotate_seconds === 'number' && c.left_rotate_seconds > 0) ? Math.round(c.left_rotate_seconds*1000)
    : 0;
  const rightRotateMs =
    (typeof c.right_rotate_ms === 'number' && c.right_rotate_ms > 0) ? Math.round(c.right_rotate_ms)
    : (typeof c.right_rotate_seconds === 'number' && c.right_rotate_seconds > 0) ? Math.round(c.right_rotate_seconds*1000)
    : 0;

  const leftSprite  = c.left_sprite  || c.image_left_sprite  || null;
  const rightSprite = c.right_sprite || c.image_right_sprite || null;

  // ---------- Image d√©tail ----------
  const leftPixel  = (typeof c.image_left_pixelated === 'boolean') ? c.image_left_pixelated : (c.image_pixelated === true);
  const rightPixel = (c.image_pixelated === true);

  let detailImg = '';
  const previewSrc = rightSrc;

  if ((leftSrc || leftSprite) && (previewSrc || rightSprite) && c.detail_pair !== false) {
    const baseH  = (typeof c.detail_pair_height === 'number' && c.detail_pair_height > 0) ? c.detail_pair_height : 180;
    const leftH  = (typeof c.detail_left_height  === 'number' && c.detail_left_height  > 0) ? c.detail_left_height  : baseH;
    const rightH = (typeof c.detail_right_height === 'number' && c.detail_right_height > 0)
                 ? c.detail_right_height
                 : (typeof c.detail_right_scale === 'number' && c.detail_right_scale > 0
                    ? Math.round(baseH * c.detail_right_scale) : baseH);
    const rightMaxW = (typeof c.detail_right_max_width === 'number' && c.detail_right_max_width > 0) ? c.detail_right_max_width : 440;

    let leftDetailNode = '';
    if (leftSprite) {
      const cfg = { ...leftSprite, src: resolveAsset(modId, leftSprite.src) };
      leftDetailNode = makeSpriteHTML('Ldet', cfg, leftH, leftPixel);
    } else {
      const rotateAttrs = (leftUrls.length > 1 && leftRotateMs > 0)
        ? ` data-rotate="left" data-urls="${leftUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${leftRotateMs}" data-idx="${leftIdx}" data-ts="${Date.now()}"`
        : '';
      leftDetailNode = `<img src="${leftSrc}" alt="block" onerror="this.style.display='none'" ${rotateAttrs} style="height:${leftH}px;width:auto;${leftPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;">`;
    }

    let rightDetailNode = '';
    if (rightSprite) {
      const cfg = { ...rightSprite, src: resolveAsset(modId, rightSprite.src) };
      rightDetailNode = makeSpriteHTML('Rdet', cfg, rightH, rightPixel, rightMaxW);
    } else {
      const rotateAttrs = (rightUrls.length > 1 && rightRotateMs > 0)
        ? ` data-rotate="right" data-urls="${rightUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${rightRotateMs}" data-idx="${rightIdx}" data-ts="${Date.now()}"` : '';
      rightDetailNode = `<img src="${previewSrc}" alt="${(title||'').replace(/"/g,'&quot;')}" onerror="this.style.display='none'" ${rotateAttrs} style="height:${rightH}px;max-width:${rightMaxW}px;width:auto;${rightPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;flex:0 0 auto;">`;
    }

    detailImg = `<div class="detail-pair" style="display:flex;align-items:flex-start;justify-content:center;gap:12px;margin:8px 0 12px;">${leftDetailNode}${rightDetailNode}</div>`;
  } else {
    if (previewSrc) {
      detailImg = `<img src="${previewSrc}" alt="${(title||'').replace(/"/g,'&quot;')}" onerror="this.style.display='none'" style="border-radius:8px;display:block;margin:8px auto 12px;max-width:440px;width:100%;${rightPixel?'image-rendering:pixelated;':'image-rendering:auto;'}">`;
    } else if (rightSprite) {
      const baseH = (typeof c.detail_right_height === 'number' && c.detail_right_height > 0) ? c.detail_right_height : (typeof c.detail_pair_height === 'number' && c.detail_pair_height > 0) ? c.detail_pair_height : 180;
      const maxW = (typeof c.detail_right_max_width === 'number' && c.detail_right_max_width > 0) ? c.detail_right_max_width : 440;
      const cfg = { ...rightSprite, src: resolveAsset(modId, rightSprite.src) };
      detailImg = makeSpriteHTML('RsoloDet', cfg, baseH, rightPixel, maxW, 'display:block;margin:8px auto 12px;');
    } else {
      detailImg = '';
    }
  }

  // --- Sections
  const details  = c.details || {};
  const sections = Array.isArray(details.sections) ? details.sections : [];

  const sectionsHtml = sections.map(sec => {
    const stitle = (lang === 'en') ? (sec.title_en || '') : (sec.title_fr || '');
    const sitems = (lang === 'en') ? (sec.items_en || []) : (sec.items_fr || []);
    const imgs = (lang === 'en') ? (sec.images_en || sec.images || []) : (sec.images_fr || sec.images || []);
    const caps = (lang === 'en') ? (sec.captions_en || sec.captions || []) : (sec.captions_fr || sec.captions || []);

    const hasContent = (stitle && stitle.trim()) || sitems.length || imgs.length;
    if (!hasContent) return '';

    const imgsHtml = imgs.length
    ? `<div class="section-images">
       ${imgs.map((raw, i) => {
         const src = resolveAsset(modId, raw);
         const cap = (caps[i] || '').trim();
         return `<figure class="sec-figure">${cap ? `<figcaption class="sec-figcap">${cap}</figcaption>` : ''}<img class="sec-img" src="${src}" alt="${(stitle||title||'').replace(/"/g,'&quot;')}" onerror="this.style.display='none'"></figure>`;
       }).join('')}
     </div>` : '';

    const listHtml = sitems.length ? `<ul style="padding-left:1.15em;">${
      sitems.map(it => {
        const txt = (it ?? '').toString();
        if (!txt.trim()) return `<li class="spacer" style="list-style:none;height:.35rem;"></li>`;
        if (/^\s*\*/.test(txt)) {
          const label = txt.replace(/^\s*\*\s*/, '');
          return `<li class="subhead" style="list-style:none;margin:8px 0 4px;text-indent:-1.15em;padding-left:1.15em;"><strong>${label}</strong></li>`;
        }
        return `<li>${txt}</li>`;
      }).join('')
    }</ul>` : '';

    return `${stitle ? `<h4 class="underline">${stitle}</h4>` : ''}${listHtml}${imgsHtml}`;
  }).join('');

  const craft = details[lang === 'en' ? 'craft_en' : 'craft_fr'] || [];
  const usage = details[lang === 'en' ? 'usage_en' : 'usage_fr'] || [];
  const drops = details[lang === 'en' ? 'drops_en' : 'drops_fr'] || [];
  const extrasHtml = `
    ${craft.length ? `<h4 class="underline">${(translations?.[lang]?.craft)||'Craft'}</h4>${renderRichList(craft)}` : ''}
    ${usage.length ? `<h4 class="underline">${(translations?.[lang]?.usage)||'Usage'}</h4>${renderRichList(usage)}` : ''}
    ${drops.length ? `<h4 class="underline">${(translations?.[lang]?.drops)||'Drops'}</h4>${renderRichList(drops)}` : ''}
  `;

  // Relancer l'animateur de sprites apr√®s le rendu
  setTimeout(() => { if (typeof ensureSpriteAnimator === 'function') ensureSpriteAnimator(); }, 50);

  return `${detailImg}${desc ? `<p>${desc}</p>` : ''}${sectionsHtml}${extrasHtml}`;
}

function showCardDetail(modId, el) {
  if (typeof hideBackToTop === 'function') hideBackToTop();
  
  const page = document.getElementById(modId);
  if (!page) return;
  
  const liste = page.querySelector('.cards-grid');
  const vue   = page.querySelector('.card-detail');
  const zone  = page.querySelector('.detail-content');
  
  if (!liste || !vue || !zone) return;

  const cardId = el.getAttribute('data-id') || '';
  if (!cardId) return;
  
  // Force le masquage de la grille
  liste.style.setProperty('display', 'none', 'important');
  
  // Force l'affichage de la vue d√©tail
  vue.style.setProperty('display', 'block', 'important');
  vue.style.setProperty('visibility', 'visible', 'important');
  vue.style.setProperty('opacity', '1', 'important');
  
  // Indicateur de chargement temporaire
  zone.innerHTML = '<p style="text-align:center;padding:2rem;opacity:0.7;">‚è≥ Chargement...</p>';
  
  // Rend le contenu d√©tail apr√®s un micro-d√©lai
  requestAnimationFrame(() => {
    try {
      zone.innerHTML = renderCardDetailContent(modId, cardId, ETAT.langue);
    } catch (e) {
      console.error('[showCardDetail] Erreur:', e);
      zone.innerHTML = `<p style="color:#c62828;">‚ùå Erreur lors du chargement de la carte.</p>`;
    }
  });
  
  try { page.querySelector('.card-detail')?.setAttribute('data-current-card-id', cardId); } catch(_){}
}

// Conserver le filtre dans l'URL quand on ouvre une carte (pour que Retour garde la liste filtr√©e)
(function patchShowCardDetail(){
  if (window.__patchShowCardDetail) return;
  window.__patchShowCardDetail = true;

  const orig = window.showCardDetail;
  if (typeof orig !== 'function') return;

  window.showCardDetail = function(modId, el){
    const id = el?.getAttribute('data-id') || '';

    // filtre "source de v√©rit√©" = ce qu'on a m√©moris√©
    let type = 'all';
    try { type = localStorage.getItem(`${modId}:lastType`) || 'all'; } catch {}

    setParams({
      p: modId,
      card: id,
      type: (type && type !== 'all') ? type : undefined
    }, false); // PUSH (pour que le bouton Retour revienne d'abord ici)

    return orig.apply(this, arguments);
  };
})();

// R√©cup√®re la cl√© de filtre active pour une page de mod
function __getActiveFilter(modId){
  // 1) ce qu'on a m√©moris√© (source de v√©rit√©)
  try {
    const saved = localStorage.getItem(`${modId}:lastType`);
    if (saved) return saved;
  } catch {}

  // 2) bouton actif dans l'UI (secours)
  const btnActive = document.querySelector(`#${modId} .side-buttons .card-btn.active`);
  if (btnActive) return btnActive.getAttribute('data-type') || 'all';

  // 3) URL (secours)
  const sp = new URLSearchParams((location.hash || '').slice(1));
  return sp.get('type') || 'all';
}

function hideCardDetail(modId) {
  const page  = document.getElementById(modId);
  if (!page) return;

  const grid  = page.querySelector('.cards-grid');
  const view  = page.querySelector('.card-detail');

  if (grid) grid.style.setProperty('display', 'grid', 'important');
  if (view) view.style.setProperty('display', 'none', 'important');

  // Filtre m√©moris√©
  let type = 'all';
  try { type = localStorage.getItem(`${modId}:lastType`) || 'all'; } catch {}

  // URL : on enl√®ve la carte, on garde le filtre si ‚â† all (REPLACE)
  if (typeof setParams === 'function') {
    setParams({
      p: modId,
      card: undefined,
      type: (type && type !== 'all') ? type : undefined
    }, true);
  }

  // R√©applique le filtre (une seule fois)
  if (typeof filterCategory === 'function') filterCategory(modId, type);
  if (typeof syncFilterActive === 'function') syncFilterActive(modId);
  if (typeof markFilterActive === 'function') markFilterActive(modId, type);

  // Back-to-top
  if (typeof updateBackToTop === 'function') updateBackToTop(modId);
  if (grid) requestAnimationFrame(() => grid.dispatchEvent(new Event('scroll')));
}

/********************
 * STATUT (status.json) ‚Äî pour mod1 / mod2
 ********************/

// Petit helper de traduction (utilise ton objet "translations")
function t(key) {
  const lang = localStorage.getItem('siteLanguage') || 'fr';
  return (translations?.[lang]?.[key]) ?? key;
}

// --- Normalise une cha√Æne (minuscule, sans accents/diacritiques)
function normalizeText(s) {
  s = (s || '').toString().toLowerCase();
  try {
    // Navigateurs modernes
    return s.normalize('NFD').replace(/\p{Diacritic}+/gu, '');
  } catch (_) {
    // Fallback
    return s.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
  }
}

// Mappe ce qui vient de status.json vers une classe CSS connue
function normalizeStatus(s) {
  const t = (s || '').toLowerCase().trim();
  if (t === 'release') return 'stable'; // "release" = stable (classe verte)
  if (t === 'developpement' || t === 'en d√©veloppement' || t === 'development' || t === 'in development')
    return 'dev';
  return t; // stable | beta | dev
}

// Libell√© affich√© (FR/EN) √† partir de la valeur BRUTE du JSON
function statusLabel(raw, lang) {
  const t = (raw || '').toLowerCase().trim();
  if (t === 'release' || t === 'stable') return (lang === 'en') ? 'Stable' : 'Stable';
  if (t === 'beta')                         return (lang === 'en') ? 'Beta'   : 'B√™ta';
  return (lang === 'en') ? 'In development' : 'En d√©veloppement';
}

// ‚Äî‚Äî‚Äî Statut (status.json) ‚Äî‚Äî‚Äî
let _lastStatusOpen = null;

// R√©cup√®re une valeur localis√©e depuis info[base]
// - supporte base_lang (ex: next_update_fr), ou objet { fr, en }, ou string simple
function pickLocalized(info, base, lang) {
  if (!info) return "";
  const direct = info[`${base}_${lang}`];
  if (typeof direct === 'string' && direct.trim()) return direct.trim();

  const node = info[base];
  if (node && typeof node === 'object') {
    const v = node[lang];
    if (typeof v === 'string' && v.trim()) return v.trim();
  }
  if (typeof node === 'string' && node.trim()) return node.trim();
  return "";
}

async function showStatus(modId) {
  const panel = document.getElementById(`status-${modId}`) || document.querySelector(`#${modId} .update-panel`);
  if (!panel) return;

  const grid   = document.querySelector(`#${modId} .cards-grid`);
  const detail = document.querySelector(`#${modId} .card-detail`);
  if (grid)   grid.style.setProperty('display', 'none', 'important');
  if (detail) detail.style.setProperty('display', 'none', 'important');
  panel.style.border = 'none';

  if (location.protocol === 'file:') {
    panel.innerHTML = `
      <p style="color:#c62828">
        Le chargement du statut est bloqu√© en <code>file://</code>.<br>
        Lance ton site via un petit serveur local (ex: VSCode Live Server ou <code>python -m http.server</code>).
      </p>`;
    panel.style.display = 'block';
    _lastStatusOpen = modId;
    return;
  }

  const STATUS_URL = new URL('status.json', document.baseURI).toString();

  let data;
  try {
    const res = await fetch(
      STATUS_URL + (STATUS_URL.includes('?') ? '&' : '?') + 't=' + Date.now(),
      { cache: 'no-store' }
    );
    if (!res.ok) throw new Error('HTTP ' + res.status);
    data = await res.json();
  } catch (e) {
    panel.innerHTML = `<p style="color:#c62828">
      Impossible de charger le statut (${e.message}).<br>
      URL tent√©e : <code>${STATUS_URL}</code>
    </p>`;
    panel.style.display = 'block';
    _lastStatusOpen = modId;
    return;
  }

  const lang = localStorage.getItem('siteLanguage') || 'fr';
  const info = data[modId];
  if (!info) {
    panel.innerHTML = `<p style="color:#c62828">Aucune information de statut pour ${modId}.</p>`;
    panel.style.display = 'block';
    _lastStatusOpen = modId;
    return;
  }

  // ‚Äî Badge texte ‚Äî normalis√©
  const stRaw = (info.status || 'dev');
  const s     = normalizeStatus(stRaw);
  const statusLabelText = statusLabel(stRaw, lang);

  // ‚Äî Date / libell√© localis√© √† c√¥t√© du badge
  // Essaie d'abord next_update (FR/EN/objet), sinon updated_at
  let dateLabel = "";
  let isIndet = false;
  const rawPlan = (
    pickLocalized(info, 'next_update', lang) ||
    pickLocalized(info, 'updated_at', lang) ||
    ''
  ).toString().trim();

  if (rawPlan) {
    const low = rawPlan.toLowerCase();
    isIndet = ['indeterminee','ind√©termin√©e','indetermine','indeterminate','unknown','n/a','-','‚Äî','?'].includes(low);

    if (isIndet) {
      dateLabel = (lang === 'fr') ? "Date ind√©termin√©e" : "Date indeterminate";
    } else {
      const d = new Date(rawPlan);
      if (isNaN(d)) {
        // üî∏ Texte libre localis√© ‚Üí tel quel (PAS de pr√©fixe)
        dateLabel = rawPlan;
      } else {
        // üî∏ Vraie date ‚Üí format + pr√©fixe i18n
        const human = d.toLocaleDateString(lang === 'fr' ? 'fr-FR' : 'en-US', { year:'numeric', month:'long', day:'numeric' });
        dateLabel = (translations[lang].planned_update || '') + human;
      }
    }
  }

  // ‚Äî Description + fonctionnalit√©s (d√©j√† bi-langue dans ton JSON)
  const desc  = (lang === 'fr') ? (info.description_fr || '') : (info.description_en || '');
  const feats = (lang === 'fr') ? (info.features_fr || [])    : (info.features_en || []);
  const featsHtml = feats.length
    ? `<h3 data-translate="planned_features">${translations[lang].planned_features}</h3>
       <ul>${feats.map(li => `<li>${li}</li>`).join('')}</ul>`
    : '';

  // ‚Äî Progression (seulement si pas stable)
  const progress = (typeof info.progress === 'number') ? Math.max(0, Math.min(100, info.progress)) : null;
  const progressHtml = (progress !== null && s !== 'stable')
    ? `
      <h3 data-translate="progress_label">${translations[lang].progress_label}</h3>
      <div class="status-progress">
        <div class="fill" style="width:${progress}%">${progress}%</div>
      </div>`
    : '';

  // ‚Äî Rendu final
  const title = translations[lang].mod_status_title;
  panel.innerHTML = `
    <div class="status-header">
      <div class="status-badge ${s}">${statusLabelText}</div>
      ${dateLabel ? `<span class="status-updated-inline${isIndet ? ' is-indet' : ''}">${dateLabel}</span>` : ""}
    </div>
    <h3>${title}</h3>
    <p>${desc}</p>
    ${progressHtml}
    ${featsHtml}
  `;

  try {
    localStorage.setItem('lastPage', modId);
    localStorage.setItem(`${modId}:lastView`, 'status');
  } catch {}
  panel.style.display = 'block';

  // Marquer le bouton "Statut" comme actif (avec petit d√©lai pour √™tre s√ªr que le DOM est pr√™t)
  requestAnimationFrame(() => {
    const sideButtons = document.querySelector(`#${modId} .side-buttons`);
    if (sideButtons) {
      // Retirer .active de tous les boutons de filtre ET retirer les styles inline
      sideButtons.querySelectorAll('.card-btn').forEach(btn => {
        btn.classList.remove('active');
        btn.removeAttribute('aria-pressed');
        // Retirer le style inline seulement si ce n'est pas le bouton statut
        if (!btn.classList.contains('update-btn')) {
          btn.style.background = '';
        }
      });
      
      // Chercher le bouton Statut avec plusieurs m√©thodes
      let statusBtn = sideButtons.querySelector('.update-btn');
      if (!statusBtn) {
        statusBtn = sideButtons.querySelector('[onclick*="showStatus"]');
      }
      if (!statusBtn) {
        statusBtn = sideButtons.querySelector('[data-translate="statut"]');
      }
      
      if (statusBtn) {
        statusBtn.classList.add('active');
        statusBtn.setAttribute('aria-pressed', 'true');
        // Forcer le style inline pour √™tre absolument s√ªr
        statusBtn.style.setProperty('background', '#1565c0', 'important');
        statusBtn.style.setProperty('color', '#fff', 'important');
        statusBtn.style.setProperty('font-weight', 'bold', 'important');
      }
    }
  });

  _lastStatusOpen = modId;
}

/********************
 * INIT
 ********************/
function initUI() {
  // Th√®me & police
  initThemeEtPolice();

  // Menus header
  initMenuLangue();
  initMenuParametres();
  initCardsLayout();
}

// D√©l√©gation unique pour les menus Langue & Param√®tres (robuste m√™me si le DOM est remplac√©)
(function wireHeaderMenusOnce() {
  if (window.__headerMenusWired) return;
  window.__headerMenusWired = true;

  document.addEventListener('click', (e) => {
    const langSelector = document.querySelector('.lang-selector');
    const settingsMenu = document.getElementById('settingsMenu');

    const langBtn      = e.target.closest('#currentLangBtn');   // bouton langue
    const settingsBtn  = e.target.closest('#settingsToggle');   // bouton ‚öô
    const langOption   = e.target.closest('.lang-option');      // option FR/EN dans le dropdown
    const insideLang   = e.target.closest('.lang-selector');    // clic √† l'int√©rieur du bloc langue
    const insideSettings = e.target.closest('#settingsMenu');   // clic √† l'int√©rieur du bloc param√®tres

    // Clic sur le bouton langue
    if (langBtn) {
      e.stopPropagation();
      settingsMenu?.classList.remove('open');           // ferme ‚öô d'abord
      langSelector?.classList.toggle('open');           // toggle menu langue
      return;
    }

    // Clic sur le bouton ‚öô
    if (settingsBtn) {
      e.stopPropagation();
      langSelector?.classList.remove('open');           // ferme langue d'abord
      settingsMenu?.classList.toggle('open');           // toggle menu ‚öô
      return;
    }

    // Clic sur une option de langue
    if (langOption) {
      e.stopPropagation();
      const lang = langOption.getAttribute('data-lang') || 'fr';
      setLanguage(lang);                                // applique la langue
      langSelector?.classList.remove('open');           // referme le menu
      return;
    }

    // Clic √† l‚Äôint√©rieur d‚Äôun des deux menus => ne rien fermer
    if (insideLang || insideSettings) {
      return;
    }

    // Clic ailleurs => fermer les deux
    langSelector?.classList.remove('open');
    settingsMenu?.classList.remove('open');
  }, /* useCapture */ true);
})();

// M√©moriser la cat√©gorie s√©lectionn√©e dans mod1/mod2 (sans changer ton filtrage)
(function rememberModFiltersOnce(){
  if (window.__rememberModFilters) return;
  window.__rememberModFilters = true;

  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#mod1 .side-buttons .card-btn[data-type], #mod2 .side-buttons .card-btn[data-type]');
    if (!btn) return;

    const page = btn.closest('.page');        // 'mod1' ou 'mod2'
    const mod  = page ? page.id : null;
    if (!mod) return;

    const type = btn.getAttribute('data-type') || 'all';
    try {
      localStorage.setItem('lastPage', mod);               // la page (mod1/mod2)
      localStorage.setItem(`${mod}:lastView`, 'grid');     // on est en "grille"
      localStorage.setItem(`${mod}:lastType`, type);       // la cat√©gorie cliqu√©e
    } catch {}
  }, true);
})();

// ‚úÖ Event delegation pour les clics sur les CARTES (mod1/mod2)
(function wireCardClicksOnce(){
  if (window.__cardClicksWired) return;
  window.__cardClicksWired = true;

  document.addEventListener('click', (e) => {
    // Cherche la carte parente
    const card = e.target.closest('.small-card[data-id][data-mod]');
    if (!card) return;
    
    const modId = card.getAttribute('data-mod');
    const cardId = card.getAttribute('data-id');
    
    if (modId && cardId && typeof showCardDetail === 'function') {
      e.preventDefault();
      e.stopPropagation();
      showCardDetail(modId, card);
    }
  }, false);
})();

/********************
 * Disposition des cartes (2√ó3 / 3√ó2)
 *********************/
function getSavedCardsLayout() {
  try {
    return localStorage.getItem('cardsLayout') || '3x2'; // d√©faut: 3 colonnes √ó 2 rang√©es
  } catch { return '3x2'; }
}

function applyCardsLayout(layout) {
  const ids = ['mod1', 'mod2'];
  ids.forEach(id => {
    const sec = document.getElementById(id);
    if (!sec) return;
    sec.classList.remove('layout-2x3', 'layout-3x2');
    sec.classList.add('layout-' + layout);
  });
  // UI du toggle
  document.querySelectorAll('.layout-toggle .layout-btn').forEach(btn => {
    btn.classList.toggle('active', btn.getAttribute('data-layout') === layout);
  });
}

function setCardsLayout(layout) {
  try { localStorage.setItem('cardsLayout', layout); } catch {}
  applyCardsLayout(layout);
}

// Appel√© au boot
function initCardsLayout() {
  applyCardsLayout(getSavedCardsLayout());
}

// --- Back to top (Patch Notes + pages de mods) --------------------------------
let _btt = null;
let _bttScrollHandler = null;
let _bttScrollTarget = null;
let _bttResizeHandler = null;
let _bttClickHandler = null;

// pages autoris√©es (ajoute ici si tu renomme)
const BTT_ALLOWED = new Set(['patchnotes', 'mod1', 'mod2', 'acatar', 'chaosium']);
const BTT_THRESHOLD = 600;   // si c'est la fen√™tre qui scrolle
const BTT_INNER_THRESHOLD = 140; // si c'est un conteneur interne

function hideBackToTop(){
  if (_btt){
    _btt.classList.remove('show');
    _btt.style.display = 'none';
  }
}

function setupBackToTop(){
  if (_btt) return;
  const btn = document.createElement('button');
  btn.className = 'back-to-top';
  btn.type = 'button';
  btn.setAttribute('aria-label', 'Haut de page');
  btn.textContent = '‚Üë';
  document.body.appendChild(btn);
  _btt = btn;
}

function getScrollTarget(pageId){
  if (pageId === 'patchnotes') return document.querySelector('#patchnotes .patch-list');
  if (pageId === 'mod1')       return document.querySelector('#mod1 .cards-grid');
  if (pageId === 'mod2')       return document.querySelector('#mod2 .cards-grid');
  return window;
}

function positionBackToTop(target){
  if (!_btt) return;
  const btn = _btt;
  const padX = 12;                 // marge mini vs bords de l‚Äô√©cran
  const offsetTop = (window.innerWidth <= 640) ? 6 : 18; // plus pr√®s du haut en mobile

  // cadre visible du scroller (viewport de la grille/liste)
  const rect = (target === window)
    ? { top: 0, left: 0, width: window.innerWidth, height: window.innerHeight }
    : (target?.getBoundingClientRect?.() || { top: 0, left: 0, width: window.innerWidth, height: window.innerHeight });

  // position : HAUT + CENTRE du viewport du scroller
  const left = Math.min(
    Math.max(rect.left + rect.width / 2 - btn.offsetWidth / 2, padX),
    window.innerWidth - padX - btn.offsetWidth
  );
  const top = Math.min(
    rect.top + offsetTop,
    window.innerHeight - btn.offsetHeight - offsetTop
  );

  btn.style.left = left + 'px';
  btn.style.top  = top  + 'px';
}

function updateBackToTop(pageId){
  setupBackToTop();
  const btn = _btt;

  // nettoie anciens listeners
  if (_bttScrollHandler && _bttScrollTarget){
    const old = (_bttScrollTarget === window) ? window : _bttScrollTarget;
    old.removeEventListener('scroll', _bttScrollHandler);
  }
  if (_bttResizeHandler){
    window.removeEventListener('resize', _bttResizeHandler);
    _bttResizeHandler = null;
  }
  if (_bttScrollHandler && _bttScrollTarget){
  const old = (_bttScrollTarget === window) ? window : _bttScrollTarget;
  old.removeEventListener('scroll', _bttScrollHandler);
  if (_bttClickHandler){
    old.removeEventListener('click', _bttClickHandler, true);
  }
}

  _bttScrollHandler = null;
  _bttClickHandler  = null;
  _bttScrollTarget  = null;

  // page non autoris√©e -> bouton totalement cach√©
  if (!BTT_ALLOWED.has(pageId)){
    btn.classList.remove('show');
    btn.style.display = 'none';
    return;
  }

  // cible de scroll
  const target = getScrollTarget(pageId) || window;
  _bttScrollTarget = target;

  // click : remonter la cible (fen√™tre OU conteneur interne)
  btn.onclick = () => {
    if (target === window) window.scrollTo({ top: 0, behavior: 'smooth' });
    else target.scrollTo({ top: 0, behavior: 'smooth' });
  };

  // gestion de l'apparition + positionnement
  const toggle = () => {
    const isWindow = (target === window);
    const pos = isWindow ? window.scrollY : target.scrollTop;
    const limit = isWindow ? BTT_THRESHOLD : BTT_INNER_THRESHOLD;
    if (pos > limit) btn.classList.add('show'); else btn.classList.remove('show');
    positionBackToTop(target);
  };

  // (r√©)abonne
  const el = (target === window) ? window : target;
  el.addEventListener('scroll', toggle, { passive: true });
  // ... apr√®s el.addEventListener('scroll', toggle, { passive: true });

const clickDismiss = (e) => {
  // Si on clique une carte ou un lien dans la zone qui d√©file, on cache le bouton
  if (e.target.closest('.cards-grid .small-card, .cards-grid a, .patch-list .patch-entry, .patch-list a')) {
    hideBackToTop();
  }
};
el.addEventListener('click', clickDismiss, true); // capture = true pour capter m√™me si navigation
  _bttClickHandler = clickDismiss;
  _bttScrollHandler = toggle;

  // visible et positionn√© (la CSS d√©cide de display initial)
  btn.style.display = '';
  // forcer l‚Äô√©tat imm√©diatement au prochain paint, sans attendre un scroll
  requestAnimationFrame(toggle);
  setTimeout(toggle, 0);
  _bttResizeHandler = () => positionBackToTop(target);
  window.addEventListener('resize', _bttResizeHandler, { passive: true });
}

window.addEventListener('DOMContentLoaded', () => {
  console.log('[INIT] pr√™t');
  // Applique langue / drapeau d√®s le d√©part
  setLanguage(ETAT.langue);

  initUI();
  const saved = localStorage.getItem('lastPage');
  const startPage = (saved && document.getElementById(saved)) ? saved : 'accueil';
  showPage(startPage);
  updateBackToTop(startPage);
});

// Gestion des filtres Patch Notes
document.addEventListener('click', (e) => {
  const btn = e.target.closest('#patchnotes .side-buttons .card-btn[data-cat]');
  if (!btn) return;

  e.preventDefault();

  // retirer .active partout, l'ajouter sur le bouton cliqu√©
  const group = btn.closest('.side-buttons');
  if (group) group.querySelectorAll('.card-btn').forEach(b => b.classList.remove('active'));
  btn.classList.add('active');

  // sauvegarder le choix
  try { localStorage.setItem('patchnotes:cat', btn.dataset.cat); } catch {}

  // relancer le rendu de la liste filtr√©e
  renderPatchList();
});

/********************
 * CARTES ‚Äî loaders & rendu
 ********************/
async function loadCards(modId) {
  if (_cache.cartes[modId]) return _cache.cartes[modId];
  const src = CARD_SOURCES[modId];
  if (!src) return [];
  const url = new URL(src, document.baseURI).toString();
  const res = await fetch(url + (url.includes('?') ? '&' : '?') + 't=' + Date.now(), { cache: 'no-store' });
  if (!res.ok) throw new Error('HTTP ' + res.status);
  const data = await res.json();
  _cache.cartes[modId] = Array.isArray(data) ? data : [];
  return _cache.cartes[modId];
}
// R√©sout un chemin d'asset *par rapport au JSON* (cards/cards_modX.json)
function resolveAsset(modId, src) {
  if (!src) return '';
  try {
    const base = new URL(CARD_SOURCES[modId], document.baseURI);
    return new URL(src, base).toString();
  } catch {
    return src; // au pire, on renvoie tel quel
  }
}

function renderCards(modId, cards) {
  const gridSel = (modId === 'mod1') ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid;
  const grid = document.querySelector(gridSel);
  if (!grid) return;

  const lang = ETAT.langue || 'fr';

  // --- UL "riche" : *Sous-titre, lignes vides = espace
  const renderRichList = (arr) => {
    const lines = Array.isArray(arr) ? arr : [];
    if (!lines.length) return '';
    return `<ul>${
      lines.map(raw => {
        const txt = (raw ?? '').toString();
        if (!txt.trim()) return `<li class="spacer" style="list-style:none;height:.35rem;"></li>`;
        if (/^\s*\*/.test(txt)) {
          const label = txt.replace(/^\s*\*\s*/, '');
          return `<li class="subhead" style="list-style:none;margin:8px 0 4px;text-indent:-1.15em;padding-left:1.15em;"><strong>${label}</strong></li>`;
        }
        return `<li>${txt}</li>`;
      }).join('')
    }</ul>`;
  };

  // --- SPRITE helper (animation frame par frame, style Minecraft)
  const makeSprite = (sideKey, cfg, targetH, pixelated = true, maxW = null, extraCSS = '') => {
    if (!cfg || !cfg.src) return '';
    // accepter frame_width|height ET frameWidth|Height
    cfg.frame_width  = cfg.frame_width  ?? cfg.frameWidth;
    cfg.frame_height = cfg.frame_height ?? cfg.frameHeight;
    if (!cfg.frames || !cfg.frame_width || !cfg.frame_height) return '';

    const frames = Math.max(1, cfg.frames|0);
    const dir    = (cfg.direction === 'horizontal') ? 'horizontal' : 'vertical';
    const fps    = (cfg.fps && cfg.fps > 0) ? cfg.fps : 6;

    // Taille d'affichage (on garde le ratio d'une frame)
    const dispH  = Math.max(1, targetH|0);
    const ratio  = cfg.frame_width / cfg.frame_height;
    const dispW  = Math.round(dispH * ratio);

    // 1 frame visible = dispW x dispH
    const bgSize = (dir === 'horizontal')
      ? `${dispW * frames}px ${dispH}px`
      : `${dispW}px ${dispH * frames}px`;

    const order     = Array.isArray(cfg.order) ? cfg.order : null;         // ex [0,1,2,3,2,1]
    const durations = Array.isArray(cfg.durations) ? cfg.durations : null; // en ms

    const pxCSS   = pixelated ? 'image-rendering:pixelated;' : 'image-rendering:auto;';
    const maxWcss = (maxW && maxW > 0) ? `max-width:${maxW}px;` : '';

    return `
      <div class="sprite-${sideKey}" data-sprite="1"
           data-frames="${frames}" data-fps="${fps}"
           data-dir="${dir}" data-fw="${cfg.frame_width}" data-fh="${cfg.frame_height}"
           ${order ? `data-order="${order.join(',')}"` : ''}
           ${durations ? `data-durations="${durations.join(',')}"` : ''}
           style="
             width:${dispW}px;height:${dispH}px;
             background-image:url('${resolveAsset(modId, cfg.src)}');
             background-repeat:no-repeat;
             background-position:0 0;
             background-size:${bgSize};
             ${pxCSS}${maxWcss}
             border-radius:8px;
             ${extraCSS}
           "></div>`;
  };

  grid.innerHTML = (cards || []).map(c => {
    const title = (lang === 'en') ? (c.title_en || c.title_fr || '') : (c.title_fr || c.title_en || '');
    const desc  = (lang === 'en') ? (c.description_en || c.description_fr || '') : (c.description_fr || c.description_en || '');

    // ---------- SOURCES d'images : gauche/droite + pools ----------
    // GAUCHE
    const leftPool = Array.isArray(c.image_left_pool) ? c.image_left_pool : [];
    const leftCandidates = leftPool.length ? leftPool : (c.image_left ? [c.image_left] : []);
    let leftIdx = 0;
    if (leftCandidates.length > 1) {
      const mode = c.left_select || 'sticky'; // 'sticky' | 'daily' | 'random'
      if (mode === 'daily') {
        const day = Math.floor(Date.now() / 86400000);
        leftIdx = day % leftCandidates.length;
      } else if (mode === 'random') {
        leftIdx = Math.floor(Math.random() * leftCandidates.length);
      } else {
        const key = 'leftChoice:' + (c.id || 'card');
        const saved = localStorage.getItem(key);
        if (saved !== null && !isNaN(+saved)) leftIdx = (+saved) % leftCandidates.length;
        else { leftIdx = Math.floor(Math.random() * leftCandidates.length); try{localStorage.setItem(key, String(leftIdx));}catch(_){} }
      }
    }
    const leftUrls = leftCandidates.map(raw => resolveAsset(modId, raw));
    const leftSrc  = leftUrls[leftIdx] || '';

    // DROITE
    const rightPool = Array.isArray(c.image_right_pool) ? c.image_right_pool
                    : (Array.isArray(c.image_pool) ? c.image_pool : []); // alias optionnel
    const rightCandidates = rightPool.length ? rightPool : (c.image ? [c.image] : []);
    let rightIdx = 0;
    if (rightCandidates.length > 1) {
      const mode = c.right_select || 'sticky';
      if (mode === 'daily') {
        const day = Math.floor(Date.now() / 86400000);
        rightIdx = day % rightCandidates.length;
      } else if (mode === 'random') {
        rightIdx = Math.floor(Math.random() * rightCandidates.length);
      } else {
        const key = 'rightChoice:' + (c.id || 'card');
        const saved = localStorage.getItem(key);
        if (saved !== null && !isNaN(+saved)) rightIdx = (+saved) % rightCandidates.length;
        else { rightIdx = Math.floor(Math.random() * rightCandidates.length); try{localStorage.setItem(key, String(rightIdx));}catch(_){} }
      }
    }
    const rightUrls = rightCandidates.map(raw => resolveAsset(modId, raw));
    const rightSrc  = rightUrls[rightIdx] || '';

    // Intervalles d‚Äôalternance auto (0 = off)
    const leftRotateMs =
      (typeof c.left_rotate_ms === 'number' && c.left_rotate_ms > 0) ? Math.round(c.left_rotate_ms)
      : (typeof c.left_rotate_seconds === 'number' && c.left_rotate_seconds > 0) ? Math.round(c.left_rotate_seconds*1000)
      : 0;
    const rightRotateMs =
      (typeof c.right_rotate_ms === 'number' && c.right_rotate_ms > 0) ? Math.round(c.right_rotate_ms)
      : (typeof c.right_rotate_seconds === 'number' && c.right_rotate_seconds > 0) ? Math.round(c.right_rotate_seconds*1000)
      : 0;

    // Sprites anim√©s (optionnels)
    const leftSprite  = c.left_sprite  || c.image_left_sprite  || null;
    const rightSprite = c.right_sprite || c.image_right_sprite || null;

    // ---------- Image miniature (GRILLE) ----------
    const leftPixel  = (typeof c.image_left_pixelated === 'boolean') ? c.image_left_pixelated : (c.image_pixelated === true);
    const rightPixel = (c.image_pixelated === true);

    const thumbStylesSolo = [
      'display:block','width:100%',
      (c.thumb_cover ? 'object-fit:cover' : 'object-fit:contain'),
      'border-radius:8px','margin-bottom:8px'
    ];
    if (typeof c.thumb_height === 'number' && c.thumb_height > 0) thumbStylesSolo.push(`height:${c.thumb_height}px`);
    else thumbStylesSolo.push('max-height:140px');
    if (rightPixel) thumbStylesSolo.push('image-rendering:pixelated');

    let thumbImg = '';
    if ((leftSrc || leftSprite) && (rightSrc || rightSprite)) {
      // DUO (gauche + droite) ‚Äî hauteur commune en carte
      const pairH =
        (typeof c.thumb_pair_height === 'number' && c.thumb_pair_height > 0) ? c.thumb_pair_height :
        (typeof c.thumb_right_height === 'number' && c.thumb_right_height > 0) ? c.thumb_right_height :
        (typeof c.thumb_height === 'number' && c.thumb_height > 0) ? c.thumb_height : 110;

      // GAUCHE
      let leftNode = '';
      if (leftSprite) {
        const leftH = (typeof c.thumb_left_height === 'number' && c.thumb_left_height > 0) ? c.thumb_left_height : pairH;
        leftNode = makeSprite('L', leftSprite, leftH, leftPixel);
      } else {
        const leftSizeStyle = (typeof c.thumb_left_width === 'number' && c.thumb_left_width > 0)
          ? `width:${c.thumb_left_width}px;height:${pairH}px;`
          : `height:${(typeof c.thumb_left_height === 'number' && c.thumb_left_height > 0) ? c.thumb_left_height : pairH}px;max-width:${pairH}px;`;
        const rotateAttrs = (leftUrls.length > 1 && leftRotateMs > 0)
          ? ` data-rotate="left" data-urls="${leftUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${leftRotateMs}" data-idx="${leftIdx}" data-ts="${Date.now()}"`
          : '';
        leftNode = `
          <img class="thumb-left" src="${leftSrc}" alt="block"
               onerror="this.style.display='none'"
               ${rotateAttrs}
               style="${leftSizeStyle}object-fit:contain;${leftPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;">`;
      }

      // DROITE
      let rightNode = '';
      if (rightSprite) {
        rightNode = makeSprite('R', rightSprite, pairH, rightPixel);
      } else {
        const rotateAttrs = (rightUrls.length > 1 && rightRotateMs > 0)
          ? ` data-rotate="right" data-urls="${rightUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${rightRotateMs}" data-idx="${rightIdx}" data-ts="${Date.now()}"`
          : '';
        rightNode = `
          <img class="thumb-right" src="${rightSrc}" alt="${(title||'').replace(/"/g,'&quot;')}"
               onerror="this.style.display='none'"
               ${rotateAttrs}
               style="height:${pairH}px;width:auto;object-fit:contain;${rightPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;margin-bottom:8px;flex:0 0 auto;">`;
      }

      thumbImg = `
        <div class="thumb-pair" style="display:flex;align-items:center;justify-content:center;gap:12px;">
          ${leftNode}
          ${rightNode}
        </div>`;
    } else {
      // UNE SEULE IMAGE / SPRITE √† droite ‚Üí centr√©
      if (rightSrc) {
        thumbImg = `<img class="thumb" src="${rightSrc}" alt="${(title||'').replace(/"/g,'&quot;')}"
                 onerror="this.style.display='none'"
                 style="display:block;margin:0 auto 8px;${thumbStylesSolo.join(';')}">`;
      } else if (rightSprite) {
        const h = (typeof c.thumb_height === 'number' && c.thumb_height > 0) ? c.thumb_height : 110;
        thumbImg = makeSprite('Rsolo', rightSprite, h, rightPixel, null, 'display:block;margin:0 auto 8px;');
      } else {
        thumbImg = '';
      }
    }

    // ---------- Image "preview" (D√âTAIL) ----------
    const previewSrc = rightSrc;
    let detailImg = '';
    if ((previewSrc || rightSprite) && (leftSrc || leftSprite) && c.detail_pair !== false) {
      // Duo en d√©tail : hauteurs ind√©pendantes possibles
      const baseH = (typeof c.detail_pair_height === 'number' && c.detail_pair_height > 0) ? c.detail_pair_height : 180;
      const leftH  = (typeof c.detail_left_height  === 'number' && c.detail_left_height  > 0) ? c.detail_left_height  : baseH;
      const rightH = (typeof c.detail_right_height === 'number' && c.detail_right_height > 0)
                   ? c.detail_right_height
                   : (typeof c.detail_right_scale === 'number' && c.detail_right_scale > 0
                      ? Math.round(baseH * c.detail_right_scale)
                      : baseH);
      const rightMaxW = (typeof c.detail_right_max_width === 'number' && c.detail_right_max_width > 0) ? c.detail_right_max_width : 440;

      // GAUCHE
      let leftDetailNode = '';
      if (leftSprite) {
        leftDetailNode = makeSprite('Ldet', leftSprite, leftH, leftPixel);
      } else {
        const rotateAttrs = (leftUrls.length > 1 && leftRotateMs > 0)
          ? ` data-rotate="left" data-urls="${leftUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${leftRotateMs}" data-idx="${leftIdx}" data-ts="${Date.now()}"`
          : '';
        leftDetailNode = `
          <img src="${leftSrc}" alt="block"
               onerror="this.style.display='none'"
               ${rotateAttrs}
               style="height:${leftH}px;width:auto;${leftPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;">`;
      }

      // DROITE
      let rightDetailNode = '';
      if (rightSprite) {
        rightDetailNode = makeSprite('Rdet', rightSprite, rightH, rightPixel, rightMaxW);
      } else {
        const rotateAttrs = (rightUrls.length > 1 && rightRotateMs > 0)
          ? ` data-rotate="right" data-urls="${rightUrls.map(u=>encodeURIComponent(u)).join(',')}" data-ms="${rightRotateMs}" data-idx="${rightIdx}" data-ts="${Date.now()}"` : '';
        rightDetailNode = `
          <img src="${previewSrc}" alt="${(title||'').replace(/"/g,'&quot;')}"
               onerror="this.style.display='none'"
               ${rotateAttrs}
               style="height:${rightH}px;max-width:${rightMaxW}px;width:auto;${rightPixel?'image-rendering:pixelated;':'image-rendering:auto;'}border-radius:8px;flex:0 0 auto;">`;
      }

      detailImg = `
        <div class="detail-pair" style="display:flex;align-items:flex-start;justify-content:center;gap:12px;margin:8px 0 12px;">
          ${leftDetailNode}
          ${rightDetailNode}
        </div>`;
    } else {
      // Sprite/IMG seule √† droite ‚Üí centr√©
      const detailImgStylesSolo = ['border-radius:8px','display:block','margin:8px auto 12px','max-width:440px','width:100%'];
      if (rightPixel) detailImgStylesSolo.push('image-rendering:pixelated');

      if (previewSrc) {
        detailImg = `<img src="${previewSrc}" alt="${(title||'').replace(/"/g,'&quot;')}"
                    onerror="this.style.display='none'" style="${detailImgStylesSolo.join(';')}">`;
      } else if (rightSprite) {
        const baseH =
          (typeof c.detail_right_height === 'number' && c.detail_right_height > 0) ? c.detail_right_height :
          (typeof c.detail_pair_height === 'number' && c.detail_pair_height > 0) ? c.detail_pair_height : 180;
        const maxW = (typeof c.detail_right_max_width === 'number' && c.detail_right_max_width > 0) ? c.detail_right_max_width : 440;
        detailImg = makeSprite('RsoloDet', rightSprite, baseH, rightPixel, maxW, 'display:block;margin:8px auto 12px;');
      } else {
        detailImg = '';
      }
    }

// ---------- Sections libres & extras ----------
const details  = c.details || {};
const sections = Array.isArray(details.sections) ? details.sections : [];

const sectionsHtml = sections.map(sec => {
  // ‚ùå plus de fallback vers l'autre langue
  const stitle = (lang === 'en') ? (sec.title_en  || '') : (sec.title_fr  || '');
  const sitems = (lang === 'en') ? (sec.items_en  || []) : (sec.items_fr  || []);

  // ‚úÖ on n'accepte que la langue courante, avec fallback √©ventuel vers un champ neutre "images"/"captions"
  const imgs = (lang === 'en')
    ? (sec.images_en   || sec.images || [])
    : (sec.images_fr   || sec.images || []);

  const caps = (lang === 'en')
    ? (sec.captions_en || sec.captions || [])
    : (sec.captions_fr || sec.captions || []);

  // ‚õî ignorer la section si elle n'a rien pour cette langue
  const hasContent = (stitle && stitle.trim()) || sitems.length || imgs.length;
  if (!hasContent) return '';

  const imgsHtml = imgs.length
  ? `<div class="section-images">
       ${imgs.map((raw, i) => {
         const src = resolveAsset(modId, raw);
         const cap = (caps[i] || '').trim();
         return `
           <figure class="sec-figure">
             ${cap ? `<figcaption class="sec-figcap">${cap}</figcaption>` : ''}
             <img class="sec-img"
                  src="${src}"
                  alt="${(stitle||title||'').replace(/"/g,'&quot;')}"
                  onerror="this.style.display='none'">
           </figure>`;
       }).join('')}
     </div>`
  : '';


  const listHtml = sitems.length ? `<ul style="padding-left:1.15em;">${
    sitems.map(it => {
      const txt = (it ?? '').toString();
      if (!txt.trim()) return `<li class="spacer" style="list-style:none;height:.35rem;"></li>`;
      if (/^\s*\*/.test(txt)) {
        const label = txt.replace(/^\s*\*\s*/, '');
        return `<li class="subhead" style="list-style:none;margin:8px 0 4px;text-indent:-1.15em;padding-left:1.15em;"><strong>${label}</strong></li>`;
      }
      return `<li>${txt}</li>`;
    }).join('')
  }</ul>` : '';

  return `${stitle ? `<h4 class="underline">${stitle}</h4>` : ''}${listHtml}${imgsHtml}`;
}).join('');

const craft = details[lang === 'en' ? 'craft_en' : 'craft_fr'] || [];
const usage = details[lang === 'en' ? 'usage_en' : 'usage_fr'] || [];
const drops = details[lang === 'en' ? 'drops_en' : 'drops_fr'] || [];
const extrasHtml = `
  ${craft.length ? `<h4 class="underline">${(translations?.[lang]?.craft)||'Craft'}</h4>${renderRichList(craft)}` : ''}
  ${usage.length ? `<h4 class="underline">${(translations?.[lang]?.usage)||'Usage'}</h4>${renderRichList(usage)}` : ''}
  ${drops.length ? `<h4 class="underline">${(translations?.[lang]?.drops)||'Drops'}</h4>${renderRichList(drops)}` : ''}
`;


    // ---------- Contenu d√©tail : rendu dynamiquement (plus d'attribut data-description) ----------
    // Le contenu sera rendu √† la demande dans showCardDetail via renderCardDetailContent

    // ---------- Render de la carte (SANS onclick inline, on utilise event delegation) ----------
    return `
      <div class="small-card ${c.type || ''}"
           data-id="${c.id || ''}"
           data-mod="${modId}">
        ${thumbImg}
        <h4>${title}</h4>
        ${desc ? `<p>${desc}</p>` : ''}
      </div>`;
  }).join('');

  // R√©applique le filtre lat√©ral actif
  const page = grid.closest('.page');
  const activeBtn = page?.querySelector('.side-buttons .card-btn.active');
  const type = activeBtn?.getAttribute('data-type') || 'all';
  if (type !== 'all') {
    grid.querySelectorAll('.small-card').forEach(card => {
      // ‚úÖ Utilise '' au lieu de 'block' pour laisser la grille CSS g√©rer l'affichage
      card.style.display = card.classList.contains(type) ? '' : 'none';
    });
  }

  // Ticker global pour l'alternance d'images (non-sprite)
  if (!window.__rotateTicker) {
    window.__rotateTicker = setInterval(() => {
      const now = Date.now();
      document.querySelectorAll('img[data-rotate]').forEach(img => {
        const ms = parseInt(img.getAttribute('data-ms'), 10) || 3000;
        const ts = parseInt(img.getAttribute('data-ts'), 10) || 0;
        if (now - ts < ms) return;
        let urls = img.__urls;
        if (!urls) {
          const raw = img.getAttribute('data-urls') || '';
          urls = raw.split(',').map(s => decodeURIComponent(s)).filter(Boolean);
          img.__urls = urls;
        }
        if (urls.length < 2) return;
        let idx = parseInt(img.getAttribute('data-idx'), 10) || 0;
        idx = (idx + 1) % urls.length;
        img.src = urls[idx];
        img.setAttribute('data-idx', String(idx));
        img.setAttribute('data-ts', String(now));
      });
    }, 500);
  }

  // Lancer/assurer l'animateur de sprites (frame par frame)
  if (typeof ensureSpriteAnimator === 'function') ensureSpriteAnimator();
}


function ensureSpriteAnimator() {
  if (window.__spriteAnim) return;

  function initNewSprites() {
    document.querySelectorAll('[data-sprite="1"]').forEach(el => {
      if (el.__spr) return;

      const frames = parseInt(el.dataset.frames, 10) || 1;
      const fps    = parseFloat(el.dataset.fps) || 6;
      const dir    = el.dataset.dir === 'horizontal' ? 'horizontal' : 'vertical';

      // ordre & dur√©es personnalis√©s (ms), fa√ßon .mcmeta
      const order = (el.dataset.order || '')
        .split(',').map(x => parseInt(x,10))
        .filter(n => !isNaN(n) && n >= 0 && n < frames);
      const durations = (el.dataset.durations || '')
        .split(',').map(x => parseInt(x,10)).filter(n => !isNaN(n) && n > 0);

      const dispW = el.clientWidth  || parseInt(getComputedStyle(el).width, 10);
      const dispH = el.clientHeight || parseInt(getComputedStyle(el).height, 10);

      el.__spr = {
        frames, fps, dir, dispW, dispH,
        idx: 0,
        order: order.length ? order : null,
        durations: durations.length ? durations : null,
        next: performance.now() + (durations.length ? durations[0] : 1000 / fps)
      };
    });
  }

  function step(t) {
    document.querySelectorAll('[data-sprite="1"]').forEach(el => {
      const s = el.__spr; if (!s) return;

      if (t >= s.next) {
        // avance l‚Äôindex (ordre custom si pr√©sent)
        if (s.order) {
          const pos = s.order.indexOf(s.idx);
          const nextPos = (pos + 1) % s.order.length;
          s.idx = s.order[nextPos];
        } else {
          s.idx = (s.idx + 1) % s.frames;
        }

        // d√©placement EXACT d'une frame √† l'autre
        const offX = (s.dir === 'horizontal') ? -(s.dispW * s.idx) : 0;
        const offY = (s.dir === 'vertical')   ? -(s.dispH * s.idx) : 0;
        el.style.backgroundPosition = `${offX}px ${offY}px`;

        // prochaine √©ch√©ance (durations[] sinon 1000/fps)
        const base = s.durations
          ? s.durations[(s.order ? s.order.indexOf(s.idx) : s.idx) % s.durations.length]
          : (1000 / s.fps);
        s.next = t + base;
      }
    });
    requestAnimationFrame(step);
  }

  // Observe les ajouts de n≈ìuds (ex : ouverture d‚Äôun d√©tail)
  const mo = new MutationObserver(initNewSprites);
  mo.observe(document.body, { childList: true, subtree: true });

  initNewSprites();
  requestAnimationFrame(step);
  window.__spriteAnim = true;
}



async function ensureCards(modId, opts = {}) {
  const gridSel = (modId === 'mod1') ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid;
  const grid = document.querySelector(gridSel);
  if (!grid) return;

  // Afficher un loader pendant le chargement
  if (!grid.querySelector('.small-card') || opts.force) {
    grid.innerHTML = '<p style="text-align:center;padding:2rem;opacity:0.7;">‚è≥ Chargement des cartes...</p>';
  }

  // option pour forcer le rechargement (clear cache)
  if (opts.force && _cache?.cartes) {
    _cache.cartes[modId] = null;
  }

  try {
    const data = await loadCards(modId);
    if (Array.isArray(data) && data.length) {
      renderCards(modId, data);

      // r√©appliquer le filtre actif (si autre que "all")
      const page = grid.closest('.page');
      const activeBtn = page?.querySelector('.side-buttons .card-btn.active');
      const type = activeBtn?.getAttribute('data-type') || 'all';
      if (type !== 'all') {
        grid.querySelectorAll('.small-card').forEach(card => {
          // ‚úÖ Utilise '' au lieu de 'block' pour laisser la grille CSS g√©rer l'affichage
          card.style.display = card.classList.contains(type) ? '' : 'none';
        });
      }
    } else {
      // si rien dans le JSON et aucune carte HTML d√©j√† pr√©sente ‚Üí petit message
      if (!grid.querySelector('.small-card')) {
        grid.innerHTML = `<p style="opacity:.7">Aucune carte trouv√©e. V√©rifie <code>${CARD_SOURCES[modId]}</code>.</p>`;
      }
    }
  } catch (e) {
    // si parse/404 et grille vide ‚Üí message clair
    if (!grid.querySelector('.small-card')) {
      grid.innerHTML = `<p style="color:#c62828">Impossible de charger <code>${CARD_SOURCES[modId]}</code> (${e.message}).</p>`;
    } else {
      console.warn('[cards]', modId, e);
    }
  }

  grid.querySelectorAll('img').forEach(img => {
    if (!img.hasAttribute('loading')) img.setAttribute('loading','lazy');
  });
}

/********************
 * CARTES ‚Äî forcer l'affichage de la grille
 ********************/
function showCards(modId) {
  const page   = document.getElementById(modId);
  if (!page) return;

  const grid   = page.querySelector('.cards-grid');
  const detail = page.querySelector('.card-detail');
  const status = page.querySelector('.update-panel');

  // Ferme Statut + le panneau d√©tail
  if (status) status.style.display = 'none';
  if (detail) detail.style.display = 'none';

  // R√©-affiche explicitement la grille en "grid"
  if (grid) grid.style.display = 'grid';
}


/********************
 * INIT ‚Äî Bouton "‚Üê Retour" (Patchnotes)
 ********************/
(function wirePatchBackOnce() {
  if (window.__patchBackWired) return;
  window.__patchBackWired = true;

  document.addEventListener('click', (e) => {
    const back = e.target.closest('#patchnotes .back-btn');
    if (!back) return;
    e.preventDefault();

    // Si tu as showPatchList(), on l‚Äôutilise, sinon on retombe sur hideCardDetail('patchnotes')
    if (typeof showPatchList === 'function') {
      showPatchList();
    } else if (typeof hideCardDetail === 'function') {
      hideCardDetail('patchnotes');
    }
  }, true);
})();

// INIT ‚Äî Bouton "‚Üê Retour" (Cartes des mods)
(function wireCardBackOnce(){
  if (window.__cardBackWired) return;
  window.__cardBackWired = true;

  document.addEventListener('click', (e) => {
    const back = e.target.closest('#mod1 .card-detail .back-btn, #mod2 .card-detail .back-btn');
    if (!back) return;
    e.preventDefault();
    e.stopPropagation();

    // 1) Si l‚ÄôURL contient d√©j√† une carte (‚Ä¶#p=modX&card=...), on remonte l'historique navigateur
    const sp = new URLSearchParams((location.hash || '').slice(1));
    // D√âSACTIV√â : history.back() causait des boucles
    // if (sp.get('card')) { history.back(); return; }

    // 2) Sinon on ferme simplement le d√©tail pour revenir √† la grille
    const page = back.closest('.page');
    if (page && typeof hideCardDetail === 'function') {
      hideCardDetail(page.id); // "mod1" | "mod2"
    }
  }, true);
})();

/********************
 * INIT ‚Äî Recherche & filtres des cartes (d√©l√©gation, fix)
 ********************/
(function wireCardsUIOnce(){
  if (window.__cardsWired) return;
  window.__cardsWired = true;

  // Ferme Statut & D√©tail et r√©-affiche la grille, en rechargeant si besoin
  async function ensureGridVisibleFrom(el) {
    const page = el.closest('.page');
    if (!page) return;
    const grid   = page.querySelector('.cards-grid');
    const detail = page.querySelector('.card-detail');
    const status = page.querySelector('.update-panel');

    if (status) status.style.display = 'none';
    if (detail) detail.style.display = 'none';
    if (!grid) return;

    // Remet la grille visible
    grid.style.display = 'grid';

    // Si aucune carte, on recharge la source JSON
    if (!grid.querySelector('.small-card')) {
      const modId = page.id; // "mod1" | "mod2"
      if (typeof ensureCards === 'function') {
        try { await ensureCards(modId); } catch(_) {}
      }
    }
  }

// Frappe dans la recherche : suggestions UNIQUEMENT (la grille ne bouge pas)
document.addEventListener('input', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;
  showSuggestions(input); // ta fonction de suggestions
}, true);


  // Filtres side-menu : <button class="card-btn" data-type="bloc|item|mob|all">
  document.addEventListener('click', async (e) => {
    // ‚õî NE PAS intercepter les clics sur les CARTES
    if (e.target.closest('.small-card[data-id]')) return;
    
    const btn = e.target.closest('.side-buttons .card-btn[data-type]');
    if (!btn) return;
    
    // On ferme le statut / d√©tail + on affiche la grille si besoin
    await ensureGridVisibleFrom(btn);

    const page = btn.closest('.page');
    const pageId = page?.id;
    if (!pageId) return;

    const type = btn.getAttribute('data-type') || 'all';

    // On passe par la fonction centrale de filtre
    if (typeof filterCategory === 'function') {
      filterCategory(pageId, type);
    }
  }, true);

  // === Suggestions de recherche (titres uniquement)
function ensureWrap(input){
  if (input.parentElement && input.parentElement.classList.contains('search-wrap')) return input.parentElement;
  const wrap = document.createElement('div');
  wrap.className = 'search-wrap';
  input.parentNode.insertBefore(wrap, input);
  wrap.appendChild(input);
  return wrap;
}
function ensureSuggestBox(wrap){
  let box = wrap.querySelector('.search-suggest');
  if (!box) {
    box = document.createElement('div');
    box.className = 'search-suggest';
    wrap.appendChild(box);
  }
  return box;
}
function buildSuggestions(input){
  const page = input.closest('.page');
  const grid = page?.querySelector('.cards-grid');
  if (!grid) return [];

  const qn = normalizeText(input.value || '');
  if (qn.length < 2) return [];

  const seen = new Set();
  const out = [];
  grid.querySelectorAll('.small-card').forEach(card => {
    const id = card.getAttribute('data-id') || '';
    const title = (card.querySelector('h4')?.textContent || '').trim();
    const tn = normalizeText(title);
    if (title && tn.includes(qn) && !seen.has(id)) {
      seen.add(id);
      out.push({ id, title, el: card });
    }
  });
  return out.slice(0, 8);
}
function showSuggestions(input){
  const wrap = ensureWrap(input);
  const box  = ensureSuggestBox(wrap);
  const sugs = buildSuggestions(input);

  if (!sugs.length) { box.classList.remove('open'); box.innerHTML = ''; return; }

  box.innerHTML = sugs.map((s,i) =>
    `<button type="button" data-id="${s.id}" ${i===0?'aria-selected="true"':''}>${s.title}</button>`
  ).join('');
  box.classList.add('open');

  // clic = ouvrir la carte (ou juste filtrer)
  box.onclick = (e) => {
    const btn = e.target.closest('button[data-id]');
    if (!btn) return;
    const page = input.closest('.page');
    const modId = page?.id || 'mod1';
    // Ouvre le d√©tail de la carte :
    const gridSel = (modId === 'mod1') ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid;
    const card = document.querySelector(`${gridSel} .small-card[data-id="${btn.dataset.id}"]`);
    if (card) showCardDetail(modId, card);
    box.classList.remove('open');
  };
}

// input/focus => MAJ suggestions
document.addEventListener('input', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;
  showSuggestions(input);
}, true);
document.addEventListener('focusin', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;
  showSuggestions(input);
}, true);

// navigation clavier
document.addEventListener('keydown', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;
  const box = input.parentElement?.querySelector('.search-suggest.open');
  if (!box) return;

  const items = Array.from(box.querySelectorAll('button[data-id]'));
  if (!items.length) return;

  const idx = Math.max(0, items.findIndex(b => b.getAttribute('aria-selected') === 'true'));
  if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
    e.preventDefault();
    const next = (e.key === 'ArrowDown') ? Math.min(items.length-1, idx+1) : Math.max(0, idx-1);
    items.forEach(b => b.removeAttribute('aria-selected'));
    items[next].setAttribute('aria-selected', 'true');
    items[next].scrollIntoView({ block: 'nearest' });
  } else if (e.key === 'Enter') {
    e.preventDefault();
    items[idx].click();
  } else if (e.key === 'Escape') {
    box.classList.remove('open');
  }
});

// Entr√©e quand la dropdown n'est PAS ouverte => appliquer la recherche (filtrer la grille)
document.addEventListener('keydown', (e) => {
  const input = e.target.closest('.search-bar');
  if (!input) return;

  // Si la dropdown est ouverte, on ne fait rien ici (la navigation au-dessus g√®re Enter)
  const box = input.parentElement?.querySelector('.search-suggest.open');
  if (box) return;

  if (e.key === 'Enter') {
    e.preventDefault();
    const page = input.closest('.page');
    const modId = page?.id; // "mod1" ou "mod2"
    if (modId && typeof searchCards === 'function') {
      searchCards(modId, input.value || '');
    }
    // (Optionnel) si tu utilises mon module d'URL (#p=...&q=...), mets √† jour le hash ici :
    if (typeof setParams === 'function') {
      setParams({ p: modId, q: input.value || '' }, true);
    }
  }
}, true);

// clic ailleurs => ferme
document.addEventListener('click', (e) => {
  const open = document.querySelector('.search-suggest.open');
  if (!open) return;
  if (!e.target.closest('.search-wrap')) open.classList.remove('open');
}, true);

})();

function notifyCopied(ok){
  const lang = localStorage.getItem('siteLanguage') || 'fr';
  const msg  = ok ? (lang === 'en' ? 'Link copied!' : 'Lien copi√© !')
                  : (lang === 'en' ? 'Copy failed'  : '√âchec de la copie');
  try { 
    // simple toast via alert pour rester vanilla
    alert(msg);
  } catch(_) {}
}

// D√©l√©gation de clic sur tous les boutons .link-copy-btn
(function wireCopyLinkOnce(){
  if (window.__copyLinkWired) return;
  window.__copyLinkWired = true;

  document.addEventListener('click', async (e) => {
  const btn = e.target.closest('.link-copy-btn');
  if (!btn) return;
  e.preventDefault();

  const ctx = btn.getAttribute('data-context') || btn.closest('.page')?.id || '';
  const url = (typeof buildDeepLink === 'function') ? buildDeepLink(ctx) : (location.origin + location.pathname + (location.hash || ''));

  let copied = false;
  try {
    await navigator.clipboard.writeText(url);
    copied = true;
  } catch {
    // Fallback si le navigateur bloque la copie
    try { window.prompt('Copie manuelle :', url); } catch {}
  }

  // Petit feedback visuel
  const old = btn.textContent;
  btn.textContent = copied ? '‚úÖ Lien copi√©' : 'üìã Copier le lien';
  setTimeout(()=> btn.textContent = old, 1200);

  // üëá Nouveau : proposer d'ouvrir le lien tout de suite dans un nouvel onglet
  const lang = (localStorage.getItem('siteLanguage') || 'fr');
  const ask  = (lang === 'en') ? 'Open this link now?' : 'Ouvrir ce lien maintenant ?';
  if (window.confirm(ask)) {
    window.open(url, '_blank', 'noopener,noreferrer');
  }
}, true);
})();

// Clic sur la PASTILLE de statut uniquement (pas le nom)
document.addEventListener('click', (e)=>{
  const pill = e.target.closest('#home-status .status-pill');
  if (!pill) return;
  e.preventDefault();

  const chip = pill.closest('.status-chip');
  const mod  = chip && chip.getAttribute('data-mod'); // "mod1" | "mod2"
  if (!mod) return;

  if (typeof setParams === 'function') setParams({ p: mod, view: 'status' }, true);
  if (typeof showPage === 'function') showPage(mod);
  if (typeof showStatus === 'function') showStatus(mod);
}, true);

// Clavier : Enter/espace sur la pastille = clic
document.addEventListener('keydown', (e)=>{
  const pill = e.target.closest('#home-status .status-pill');
  if (!pill) return;
  if (e.key !== 'Enter' && e.key !== ' ') return;
  e.preventDefault();
  pill.click();
});

/********************
 * INIT ‚Äî Bandeau : lien actif
 ********************/
(function wireHeaderNavActive(){
  if (window.__navActiveWired) return;
  window.__navActiveWired = true;

  function setActiveNavById(pageId) {
    const links = document.querySelectorAll('.bandeau nav a');
    links.forEach(a => {
      const href = a.getAttribute('href') || '';
      const data = a.getAttribute('data-page') || '';
      const target =
        (data || '').replace(/^#/, '') ||
        (href.includes('#') ? href.split('#').pop() : '').replace(/^#/, '');
      a.classList.toggle('active', target === pageId);
    });
  }

  // clique sur le bandeau
  document.addEventListener('click', (e) => {
    const a = e.target.closest('.bandeau nav a');
    if (!a) return;
    const href = a.getAttribute('href') || '';
    const data = a.getAttribute('data-page') || '';
    const pageId = (data || (href.includes('#') ? href.split('#').pop() : '')).replace(/^#/, '');
    if (pageId) setActiveNavById(pageId);
  }, true);

  // expose une fonction globale pour l‚Äôutiliser depuis showPage(id)
  window.__setActiveNavById = setActiveNavById;
})();

// ==== INIT: Chips de statut sous le header (Accueil) ====
(function initHomeStatusOnce(){
  if (window.__homeStatusInit) return; window.__homeStatusInit = true;

  async function loadStatus(){
    try{
      const res = await fetch('status.json?t=' + Date.now(), { cache:'no-store' });
      if (!res.ok) throw new Error('HTTP ' + res.status);
      return await res.json();
    }catch(_){ return {}; }
  }
  function labelFor(s, lang){
    const st = (s||'').toLowerCase();
    if (lang==='en') return st==='stable'?'Stable': st==='beta'?'Beta':'In development';
    return st==='stable'?'Stable': st==='beta'?'B√™ta':'En d√©veloppement';
  }

  function classFor(s){
    const st = (s||'').toLowerCase();
    return st==='stable'?'is-stable': st==='beta'?'is-beta':'is-dev';
  }

  // Mappe ce qui vient de status.json vers une classe CSS connue
 function normalizeStatus(s) {
   const t = (s || '').toLowerCase().trim();
   if (t === 'release') return 'stable'; // <= ici on force "release" √† devenir "stable"
   if (t === 'developpement' || t === 'en d√©veloppement' || t === 'development' || t === 'in development')
     return 'dev';
   return t; // stable | beta | dev | (autres inchang√©s)
 }

 // Libell√© √† afficher (FR/EN) √† partir de la valeur brute du JSON
 function statusLabel(raw, lang) {
   const t = (raw || '').toLowerCase().trim();
   if (t === 'release' || t === 'stable') return (lang === 'en') ? 'Stable' : 'Stable';
   if (t === 'beta')                         return (lang === 'en') ? 'Beta'   : 'B√™ta';
   // tout le reste (dev, in development, etc.)
   return (lang === 'en') ? 'In development' : 'En d√©veloppement';
}


  function paint(map){
  const lang = localStorage.getItem('siteLanguage') || 'fr';
  document.querySelectorAll('#home-status .status-chip').forEach(btn=>{
    const mod    = btn.getAttribute('data-mod');            // "mod1" | "mod2"
    const name   = (mod==='mod1' ? 'Acatar' : mod==='mod2' ? 'Chaosium' : (mod||''));
    const stRaw  = map?.[mod]?.status || '';                // ex: "release"
    const stNorm = normalizeStatus(stRaw);                  // -> "stable"
    const label  = statusLabel(stRaw, lang);                // -> "Stable"

    // "Nom : [pastille]"
    btn.innerHTML =
      `<span class="mod-name">${name}</span><span class="sep" aria-hidden="true">:</span>
      <span class="status-pill ${stNorm || ''}" tabindex="0" role="button"
            aria-label="${(lang==='en'?'Open status: ':'Ouvrir le statut : ')+name}">
        ${label}
      </span>`;
    if (stNorm) btn.setAttribute('data-status', stNorm);
  });
  }


  // üëá expose un refresh global (utile quand on change la langue)
  window.__refreshHomeChips = () => loadStatus().then(paint);

  // premier rendu
  window.__refreshHomeChips();
})();

// Ajoute/actualise le petit titre "Statut :" dans #home-status
function ensureStatusTitle(){
  const bar = document.getElementById('home-status');
  if (!bar) return;

  // cr√©e le titre s'il n'existe pas
  let title = bar.querySelector('.status-title');
  if (!title) {
    title = document.createElement('span');
    title.className = 'status-title';
    title.setAttribute('aria-hidden', 'true'); // non interactif
    bar.prepend(title);
  }
  const lang = (localStorage.getItem('siteLanguage') || 'fr');
  title.textContent = (lang === 'en') ? 'Status:' : 'Statut :';
}

// S‚Äôassure que le bon lien est actif apr√®s recharge
window.addEventListener('DOMContentLoaded', () => {
  const visible = Array.from(document.querySelectorAll('.page'))
    .find(p => getComputedStyle(p).display !== 'none');
  const id = visible ? visible.id : 'accueil';
  document.querySelectorAll('.bandeau nav a').forEach(a => a.classList.remove('active'));
  const nav = document.getElementById('nav-' + id);
  if (nav) nav.classList.add('active');
});

// Drawer mobile
(function wireMobileDrawer(){
  const drawer = document.getElementById('mobileDrawer');
  const btn    = document.getElementById('mobileMenuBtn');
  if (!drawer || !btn) return;

  function openDrawer(){
    drawer.classList.add('open');
    drawer.setAttribute('aria-hidden', 'false');
    btn.setAttribute('aria-expanded', 'true');
  }
  function closeDrawer(){
    drawer.classList.remove('open');
    drawer.setAttribute('aria-hidden', 'true');
    btn.setAttribute('aria-expanded', 'false');
  }
  window.openPageFromDrawer = function(pageId){
    showPage(pageId);
    closeDrawer();
  };

  btn.addEventListener('click', (e)=>{ e.stopPropagation(); drawer.classList.contains('open') ? closeDrawer() : openDrawer(); });
  drawer.addEventListener('click', (e)=>{ if (e.target.matches('[data-close], .drawer-backdrop')) closeDrawer(); });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') closeDrawer(); });
})();

// Ouvre le panneau Param√®tres depuis le drawer
function openSettingsPanel() {
  const settingsMenu   = document.getElementById('settingsMenu');   // wrapper du bouton ‚öô + panneau
  const settingsPanel  = document.getElementById('settingsPanel');  // le panneau
  const langSelector   = document.querySelector('.lang-selector');  // le menu langue (√† fermer)

  if (!settingsMenu || !settingsPanel) return;

  // Fermer la langue si ouverte
  if (langSelector) langSelector.classList.remove('open');

  // Ouvrir le panneau param√®tres (compat .open ET .panel-open)
  settingsMenu.classList.add('open');
  settingsMenu.classList.add('panel-open');

  // Ceinture + bretelles si une r√®gle CSS met display:none
  settingsPanel.style.display = 'block';

  // ARIA (facultatif)
  const toggle = document.getElementById('settingsToggle');
  if (toggle) toggle.setAttribute('aria-expanded', 'true');
}

// Ouvrir le panneau Param√®tres depuis le drawer (en diff√©r√© pour √©viter le close global)
function openSettingsFromDrawer(e) {
  if (e) { e.preventDefault(); e.stopPropagation(); }
  // ferme le drawer d'abord
  if (typeof closeDrawer === 'function') closeDrawer();
  // puis ouvre les param√®tres apr√®s la fin de ce clic
  setTimeout(() => {
    const btn = document.getElementById('settingsToggle');
    if (btn) btn.click(); // utilise ta logique existante d'ouverture
  }, 80);
  return false;
}

function setThemeFromDrawer(cls) {
  ETAT.theme = cls;
  localStorage.setItem('siteTheme', cls);
  if (typeof appliquerThemeEtPolice === 'function') {
    appliquerThemeEtPolice();
  } else if (typeof applyThemeAndFont === 'function') {
    applyThemeAndFont();
  } else {
    const root = document.documentElement;
    root.classList.remove('theme-sombre','theme-clair', 'theme-bleu');
    root.classList.add(cls);
  }
}

function setFontFromDrawer(cls) {
  ETAT.fontSize = cls;
  localStorage.setItem('siteFont', cls);
  if (typeof appliquerThemeEtPolice === 'function') {
    appliquerThemeEtPolice();
  } else if (typeof applyThemeAndFont === 'function') {
    applyThemeAndFont();
  } else {
    const root = document.documentElement;
    root.classList.remove('font-normal','font-grand','font-tres-grand');
    root.classList.add(cls);
  }
}

// ---------- Liens entre cartes (ex: <a data-card-id="baton_forge">B√¢ton forg√©</a>)
async function gotoCard(modId, cardId) {
  const page = document.getElementById(modId);
  if (!page) return;
  
  // revenir sur la grille si un panneau est ouvert
  if (typeof showCards === 'function') showCards(modId);

  const gridSel = (modId === 'mod1') ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid;
  const grid = document.querySelector(gridSel);
  if (!grid) return;

  // Attendre un petit d√©lai pour que les cartes soient rendues
  await new Promise(resolve => setTimeout(resolve, 100));

  // essaie d'ouvrir tout de suite
  let el = grid.querySelector(`.small-card[data-id="${cardId}"]`);
  if (el) {
    showCardDetail(modId, el);
    try { el.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_){}
    return;
  }

  // si la carte n'est pas encore rendue, (re)charge et r√©essaie
  if (typeof ensureCards === 'function') {
    await ensureCards(modId);
    // Attendre un peu apr√®s le chargement
    await new Promise(resolve => setTimeout(resolve, 100));
    el = grid.querySelector(`.small-card[data-id="${cardId}"]`);
    if (el) {
      showCardDetail(modId, el);
      try { el.scrollIntoView({ behavior:'smooth', block:'center' }); } catch(_){}
    }
  }
}

// capture les clics sur <a data-card-id="...">
document.addEventListener('click', (e) => {
  const link = e.target.closest('a[data-card-id]');
  if (!link) return;

  e.preventDefault();
  // d√©duire le mod depuis la page courante
  const page = link.closest('.page');
  const modId =
    page?.id ||
    (document.getElementById('mod1')?.style.display !== 'none' ? 'mod1' : 'mod2');

  const targetId = link.getAttribute('data-card-id');
  if (targetId) gotoCard(modId, targetId);
}, true);

/********************
 * NAVIGATION ENTRE CARTES (pile d'historique sans double push)
 ********************/
(function wireCardHistory() {
  if (window.__cardHistoryWired) return;
  window.__cardHistoryWired = true;

  const HISTORY = { mod1: [], mod2: [], backNav: false };

  const getDetailEl  = (m) => document.querySelector(`#${m} .card-detail`);
  const getCurrentId = (m) => getDetailEl(m)?.getAttribute('data-current-card-id') || null;
  const setCurrentId = (m, id) => { const d = getDetailEl(m); if (d) d.setAttribute('data-current-card-id', id || ''); };
  const gridSel      = (m) => (m === 'mod1' ? SELECTEURS.mod1Grid : SELECTEURS.mod2Grid);

  // --- showCardDetail : push l'ancienne carte (sauf pendant un "retour")
  const origShow = window.showCardDetail;
  if (typeof origShow === 'function') {
    window.showCardDetail = function(modId, el, ...rest) {
      try {
        const curr = getCurrentId(modId);
        const next = el?.getAttribute('data-id');
        if (!HISTORY.backNav && curr && next && curr !== next) {
          (HISTORY[modId] ||= []).push(curr);
        }
      } catch (_) {}
      const res = origShow.apply(this, [modId, el, ...rest]);
      try { setCurrentId(modId, el?.getAttribute('data-id') || null); } catch (_) {}
      HISTORY.backNav = false; // fin du mode retour
      return res;
    };
  }

  // --- hideCardDetail : revenir d'abord √† la carte pr√©c√©dente, sinon √† la grille
  const origHide = window.hideCardDetail;
  if (typeof origHide === 'function') {
    window.hideCardDetail = function(modId, ...rest) {
      const prev = (HISTORY[modId] || []).pop();
      if (prev) {
        const grid = document.querySelector(gridSel(modId));
        const el = grid?.querySelector(`.small-card[data-id="${prev}"]`);
        if (el) {
          HISTORY.backNav = true;                 // emp√™che tout "re-push"
          return window.showCardDetail(modId, el);
        }
      }
      setCurrentId(modId, null);
      return origHide.apply(this, [modId, ...rest]);
    };
  }

  // --- gotoCard : NE PUSH PLUS (c'est showCardDetail qui s'en charge)
  const origGoto = window.gotoCard;
  if (typeof origGoto === 'function') {
    window.gotoCard = function(modId, cardId) {
      HISTORY.backNav = false;
      return origGoto.apply(this, arguments);
    };
  }

  // --- change de page : purge la pile
  const origShowPage = window.showPage;
  if (typeof origShowPage === 'function') {
    window.showPage = function(pageId) {
      HISTORY.mod1 = []; HISTORY.mod2 = []; HISTORY.backNav = false;
      return origShowPage.apply(this, arguments);
    };
  }
})();

// === URL State: #p=page&type=...&q=...&card=...&pn=...
(function wireUrlState(){
  if (window.__urlStateWired) return;
  window.__urlStateWired = true;

  const getParams = () => new URLSearchParams((location.hash || '').replace(/^#/, ''));
  function setParams(upd, replace=true){
    const sp = getParams();
    Object.entries(upd || {}).forEach(([k,v]) => {
      if (v === null || v === undefined || v === '') sp.delete(k); else sp.set(k, v);
    });
    const h = '#' + sp.toString();
    if (replace) history.replaceState(null, '', h); else location.hash = h;
  }

  // Applique le hash (au changement ET au chargement)
  async function applyFromHash(){
    const sp = getParams();
    const p  = sp.get('p') || localStorage.getItem('lastPage') || 'accueil';
    
    // ‚úÖ Attendre que la page soit charg√©e avant d'appliquer filtres/recherche/carte
    if (typeof showPage === 'function') await showPage(p);

    // MOD pages : filtre/recherche/carte
    if (p === 'mod1' || p === 'mod2') {
      // filtre
      const type = sp.get('type');
      if (type) {
        const btn = document.querySelector(`#${p} .side-buttons .card-btn[data-type="${type}"]`);
        if (btn) {
          btn.click();
          // Attendre que le filtre soit appliqu√© avant d'ouvrir la carte
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }
      // recherche
      const q = sp.get('q') || '';
      const input = document.querySelector(`#${p} .search-bar`);
      if (input) {
        input.value = q;
        // d√©clenche la recherche existante
        const ev = new Event('input', { bubbles:true });
        input.dispatchEvent(ev);
      }
      // carte ouverte (apr√®s le filtre pour qu'elle soit visible)
      const card = sp.get('card');
      if (card) {
        if (typeof gotoCard === 'function') await gotoCard(p, card);
      }
    }

    // Patchnotes : d√©tail
    if (p === 'patchnotes') {
      const pn = sp.get('pn');
      if (pn && typeof showPatchDetail === 'function') {
        try { await showPatchDetail(pn); } catch(_){}
      } else {
        if (typeof showPatchList === 'function') showPatchList();
      }
    }
  }

  // 1) Binder les interactions ‚Üí MAJ du hash
  // page
  const origShowPage = window.showPage;
  if (typeof origShowPage === 'function') {
    window.showPage = function(pageId) {
      setParams({ p: pageId }, true);
      return origShowPage.apply(this, arguments);
    };
  }

  // filtre (boutons lat√©raux)
  document.addEventListener('click', (e) => {
    const btn = e.target.closest('#mod1 .side-buttons .card-btn[data-type], #mod2 .side-buttons .card-btn[data-type]');
    if (!btn) return;
    const page = btn.closest('.page')?.id;
    if (!page) return;
    setParams({ p: page, type: btn.getAttribute('data-type') || 'all' }, true);
  }, true);

  // recherche : n‚Äô√©crit q= dans le hash QUE √† la validation (Enter)
  document.addEventListener('keydown', (e) => {
    const input = e.target.closest('#mod1 .search-bar, #mod2 .search-bar');
    if (!input || e.key !== 'Enter') return;
    const page = input.closest('.page')?.id;
    if (!page) return;
    setParams({ p: page, q: input.value || '' }, true);
  }, true);

  // d√©tail carte ‚Üí garde le type courant dans l‚ÄôURL
  const origShow = window.showCardDetail;
  if (typeof origShow === 'function') {
    window.showCardDetail = function(modId, el) {
      const id = el?.getAttribute('data-id') || '';
      const sp = new URLSearchParams((location.hash || '').replace(/^#/, ''));
      const type = sp.get('type') || null;
      setParams({ p: modId, card: id, type: type || undefined }, true);
      return origShow.apply(this, arguments);
    };
  }

  // d√©tail patchnote
  const origPN = window.showPatchDetail;
  if (typeof origPN === 'function') {
    window.showPatchDetail = function(id) {
      setParams({ p:'patchnotes', pn: id }, true);
      return origPN.apply(this, arguments);
    };
  }
  const origPNList = window.showPatchList;
  if (typeof origPNList === 'function') {
    window.showPatchList = function() {
      setParams({ pn: null }, true);
      return origPNList.apply(this, arguments);
    };
  }

  // 2) Suivre les changements d‚ÄôURL + au chargement
  window.addEventListener('hashchange', applyFromHash);
  window.addEventListener('DOMContentLoaded', applyFromHash);
})();

// ===== Copier le lien du d√©tail courant (cartes / patchnotes)
(function wireCopyLinkOnce(){
  if (window.__copyLinkWired) return;
  window.__copyLinkWired = true;

  function buildDeepLink(ctx){
    const base = location.origin + location.pathname;
    if (ctx === 'patchnotes') {
      const id = document.querySelector('#patchnotes .card-detail')?.getAttribute('data-current-patch-id');
      return base + (id ? `#p=patchnotes&pn=${encodeURIComponent(id)}` : '#p=patchnotes');
    }
    if (ctx === 'mod1' || ctx === 'mod2') {
      const id = document.querySelector(`#${ctx} .card-detail`)?.getAttribute('data-current-card-id');
      // R√©cup√©rer le filtre actif
      let activeType = 'all';
      try {
        activeType = localStorage.getItem(`${ctx}:lastType`) || 'all';
      } catch {}
      
      // Construire l'URL avec le filtre si diff√©rent de "all"
      if (id) {
        const typeParam = (activeType && activeType !== 'all') ? `&type=${activeType}` : '';
        return base + `#p=${ctx}${typeParam}&card=${encodeURIComponent(id)}`;
      }
      return base + `#p=${ctx}`;
    }
    return base + (location.hash || '');
  }

  document.addEventListener('click', async (e) => {
    const btn = e.target.closest('.link-copy-btn');
    if (!btn) return;
    e.preventDefault();

    const ctx = btn.getAttribute('data-context') || btn.closest('.page')?.id || '';
    const url = buildDeepLink(ctx);

    try {
      await navigator.clipboard.writeText(url);
      // petit feedback visuel
      const old = btn.textContent;
      btn.textContent = '‚úÖ Lien copi√©';
      setTimeout(()=> btn.textContent = old, 1200);
    } catch {
      // Fallback si le navigateur bloque le presse-papiers (HTTP, file://, etc.)
      try { window.prompt('Copie manuelle :', url); } catch {}
    }
  }, true);
})();

// ‚Äî‚Äî‚Äî Module Nouveaut√©s / Carrousel auto (clean + planification) ‚Äî‚Äî‚Äî
(function () {
  var MAX_SLIDES  = 10;
  var AUTOPLAY_MS = 4000;

  // Images par d√©faut par mod (laisse "" si tu n‚Äôen veux pas)
  var MOD_IMAGES = {
    acatar:   "images/ui/new_logo_acatar.png",
    chaosium: "images/ui/chaosium_image.png",
    maintenance: "images/ui/maintenance_warning.jpg",
    sirens: "images/ui/phax_sirens_image.png",
  };

  var STATE = { items: [], idx: 0, timer: null, _newsTimer: null };

  // ‚Äî‚Äî utils
  function clsStage(s){ s=String(s||'').toLowerCase(); if(s==='release')return'release'; if(s==='beta')return'beta'; if(s==='alpha')return'alpha'; return'dev'; }
  function t(lang,key,def){ try{var pack=window.translations&&window.translations[lang]; return (pack&&pack[key])||def;}catch{return def;} }
  function pickLoc(it,lang){
    var title=(lang==='fr'?(it.title_fr||it.title_en):(it.title_en||it.title_fr))||"";
    var summary=(lang==='fr'?(it.summary_fr||it.summary_en):(it.summary_en||it.summary_fr))||"";
    return { title:String(title), summary:String(summary) };
  }

  // ‚Äî‚Äî‚Äî patchnotes ‚Üí card
  function fromPatch(p, pinned){
    var mod = String(p.mod || '').toLowerCase();

    function stageFromPatch(pp){
      if (pp && pp.beta === true)  return 'beta';
      if (pp && pp.alpha === true) return 'alpha';
      var s = String(pp && (pp.stage || pp.type) || '').toLowerCase();
      if (s === 'beta' || s === 'b√™ta')   return 'beta';
      if (s === 'alpha')                  return 'alpha';
      if (s === 'release' || s === 'stable' || s === 'final') return 'release';
      return 'dev';
    }

    function extract(lang){
      var key  = (lang === 'fr') ? 'sections_fr' : 'sections_en';
      var secs = Array.isArray(p[key]) ? p[key] : [];
      if (!secs.length) return [];
      var prefIdx = secs.findIndex(s =>
        String(s.title || '').toUpperCase().startsWith(lang === 'fr' ? 'AJOUT' : 'ADD')
      );
      var s = secs[prefIdx >= 0 ? prefIdx : secs.findIndex(x => Array.isArray(x.items) && x.items.length)];
      s = s || secs[0];
      var items = Array.isArray(s?.items) ? s.items : [];
      return items
        .filter(v => typeof v === 'string')
        .map(v => v.trim())
        .filter(Boolean)
        .slice(0, 5);
    }

    return {
      custom:     false,
      pinned:     !!pinned,
      date:       p.date || '',
      title_fr:   p.title_fr || p.title || '',
      title_en:   p.title_en || p.title || '',
      summary_fr: p.summary_fr || p.summary || '',
      summary_en: p.summary_en || p.summary || '',
      stage:      stageFromPatch(p),
      patch_id:   String(p.id || ''),
      link:       '#p=patchnotes&pn=' + encodeURIComponent(p.id || ''),
      mod:        mod,
      image:      p.image || MOD_IMAGES[mod] || '',
      features_fr: extract('fr'),
      features_en: extract('en'),

      // pas de planification sur patchnotes par d√©faut
      show_after: null,
      hide_after: null,
      type: ''
    };
  }

  function pickFeatures(it, lang){
    var arr = (lang === 'fr') ? it.features_fr : it.features_en;
    return Array.isArray(arr) ? arr.filter(Boolean) : [];
  }

  function sortNews(arr){
    return (arr||[]).slice().sort(function(a,b){
      var ap=a&&a.pinned?1:0, bp=b&&b.pinned?1:0; if(ap!==bp)return bp-ap;
      // tri desc sur show_after/date si dispo
      var ad = Date.parse(a.show_after||a.date||'') || 0;
      var bd = Date.parse(b.show_after||b.date||'') || 0;
      return bd - ad;
    }).slice(0,MAX_SLIDES);
  }

  // ‚Äî‚Äî‚Äî planification (show_after/hide_after)
  function _parseISO(s){ if(!s) return null; var d=new Date(s); return isNaN(d)?null:d; }
  function _isLive(it, now){
    var show=_parseISO(it.show_after || it.date);
    var hide=_parseISO(it.hide_after);
    if (show && now < show) return false;
    if (hide && now >= hide) return false;
    return true;
  }
  function _nextChangeMs(it, now){
    var ms=Infinity;
    var show=_parseISO(it.show_after || it.date);
    var hide=_parseISO(it.hide_after);
    if (show && now < show) ms=Math.min(ms, show-now);
    if (hide && now < hide) ms=Math.min(ms, hide-now);
    return ms;
  }

  async function loadAll(){
    function bust(u){return u+(u.indexOf('?')>=0?'&':'?')+'t='+Date.now();}
    var NEWS_URL  = new URL('news.json', document.baseURI).toString();
    var PATCH_URL = new URL('patchnotes.json', document.baseURI).toString();

    var rawNews=[];
    try{ var rN=await fetch(bust(NEWS_URL),{cache:'no-store'}); if(!rN.ok)throw 0; rawNews=await rN.json(); }catch{ rawNews=[]; }

    var patchMap=new Map();
    try{
      var rP=await fetch(bust(PATCH_URL),{cache:'no-store'});
      if(rP.ok){ var arr=await rP.json(); (Array.isArray(arr)?arr:[]).forEach(function(p){ if(p&&p.id)patchMap.set(String(p.id),p); }); }
    }catch{}

    var resolved=[];
    (Array.isArray(rawNews)?rawNews:[]).forEach(function(n){
      if(!n) return;

      // ‚Äî CUSTOM NEWS ‚Äî
      if (n.custom) {
        var modKeyRaw = String(n.mod || '').toLowerCase();
        var isMaint   = (n.type === 'maintenance') || (modKeyRaw === 'maintenance');
        var isAnnouncement = (n.type === 'announcement');

        var img =
          n.image ||
          (isMaint ? (MOD_IMAGES.maintenance || '') : '') ||
          (MOD_IMAGES[modKeyRaw] || '');

        var link = (isMaint || isAnnouncement) ? '' : (n.link || n.cta_link || '');

        var stageVal = isAnnouncement ? '' : (n.stage || 'dev');

        resolved.push({
          custom: true,
          pinned: !!n.pinned,
          date: n.date || '',
          title_fr: n.title_fr || '',
          title_en: n.title_en || '',
          summary_fr: n.summary_fr || '',
          summary_en: n.summary_en || '',
          features_fr: Array.isArray(n.features_fr) ? n.features_fr : [],
          features_en: Array.isArray(n.features_en) ? n.features_en : [],
          stage: stageVal,
          type: n.type || '',
          patch_id: '',
          link: link,
          mod: isMaint ? 'maintenance' : modKeyRaw,
          image: img,
          cta_link: n.cta_link || '',
          cta_label_fr: n.cta_label_fr || '',
          cta_label_en: n.cta_label_en || '',
          credit_link: n.credit_link || '',
          credit_label_fr: n.credit_label_fr || '',
          credit_label_en: n.credit_label_en || '',
          // planification
          show_after: n.show_after || null,
          hide_after: n.hide_after || null
        });
        return;
      }

      // ‚Äî PATCHNOTE R√âF√âRENC√âE ‚Äî
      var p = n.id ? patchMap.get(String(n.id)) : null;
      if (p) {
        // On g√©n√®re la carte √† partir du patch
        var card = fromPatch(p, !!n.pinned);

        // Surcharges optionnelles venant de news.json
        if (n.show_after) card.show_after = n.show_after;
        if (n.hide_after) card.hide_after = n.hide_after;

        // Si tu veux pouvoir changer le type (par ex. "urgent" plus tard)
        if (n.type) card.type = n.type;

        // (optionnel) au cas o√π tu veuilles forcer un mod diff√©rent
        // if (n.mod) card.mod = String(n.mod).toLowerCase();

        resolved.push(card);
      }
    });

    // ‚Äî‚Äî Filtrage + r√©veil
    var now = new Date();
    var visible = (resolved||[]).filter(function(n){ return _isLive(n, now); });
    STATE.items = sortNews(visible);

    if (STATE._newsTimer){ clearTimeout(STATE._newsTimer); STATE._newsTimer=null; }
    var allNext = (resolved||[]).map(function(n){ return _nextChangeMs(n, now); }).filter(Number.isFinite);
    if (allNext.length){
      var wait = Math.min.apply(Math, allNext); // √©quiv. √† Math.min(...allNext)
      STATE._newsTimer = setTimeout(async function(){
        try{ await loadAll(); }catch(e){ console.warn(e); }
        if (window.__refreshNewsLang) window.__refreshNewsLang();
      }, Math.min(Math.max(wait, 1000), 24*60*60*1000));
    }
  }

  // ‚Äî‚Äî‚Äî rendu
  function buildDetailHTML(it, lang){
    function defaultHint(l){
      return (l === 'en')
        ? 'Some highlights ‚Äî press ‚ÄúLearn more‚Äù to see details.'
        : 'Quelques nouveaut√©s ‚Äî appuyez sur ¬´ En savoir plus ¬ª pour voir le d√©tail.';
    }

    var isAnnouncement = (it.type === 'announcement');
    var iconAnnouncement = isAnnouncement ? '<span class="news-icon" title="Annonce">üì¢</span>' : '';
    var isUrgent = (it.type === 'urgent');


    var titleRaw = (lang === 'fr' ? (it.title_fr || it.title_en) : (it.title_en || it.title_fr)) || '';
    var title = String(titleRaw).trim();

    var summaryTxt = ((lang === 'fr' ? (it.summary_fr || it.summary_en) : (it.summary_en || it.summary_fr)) || '').trim();
    var summaryToShow = isAnnouncement ? summaryTxt : (summaryTxt || defaultHint(lang));

    var modLabel =
      it.mod === 'chaosium' ? (translations?.[lang]?.chaosium || 'Chaosium') :
      it.mod === 'acatar'   ? (translations?.[lang]?.acatar   || 'Acatar')   :
      it.mod === 'sirens'   ? (translations?.[lang]?.sirens   || 'Phax Sirens')   :
      (it.mod === 'maintenance' ? (lang === 'fr' ? 'Maintenance' : 'Maintenance') : '');

    var version = it.version ? String(it.version) : '';
    if (!version) {
      var m = /\bv?(\d+(?:\.\d+){0,3})\b/i.exec(title);
      if (m) version = 'v' + m[1];
    }

    var metaParts = [];
    if (modLabel) metaParts.push('<span class="news-meta">'+modLabel+'</span>');
    if (it.date)   metaParts.push('<span class="news-meta">'+it.date+'</span>');
    var meta = metaParts.join(' ');

    var badge = '';

    // 1) URGENT : toujours prioritaire
    if (isUrgent) {
      badge = '<span class="stage-badge stage-urgent">URGENT</span>';
    }
    // 2) Annonce : badge NEWS bleu
    else if (isAnnouncement) {
      var newsLabel = (lang === 'fr' ? 'NEWS' : 'NEWS');
      badge = '<span class="stage-badge stage-news">'+newsLabel+'</span>';
    }
    // 3) Cas normal : dev / beta / stable comme avant
    else if (it.stage) {
      badge = '<span class="stage-badge '+clsStage(it.stage)+'">'+String(it.stage).toUpperCase()+'</span>';
    }

    var hasImg = !!it.image;
    var visual = hasImg ? '<div class="visual"><img src="'+it.image+'" alt=""></div>' : '';

    var feats = pickFeatures(it, lang).slice(0, 5);
    var featsHTML = (!isAnnouncement && feats.length)
      ? '<ul class="news-features">' + feats.map(function(li){ return '<li>'+li+'</li>'; }).join('') + '</ul>'
      : '';

    var creditHTML = "";
    if (it.credit_link) {
      var creditLabel = (lang === 'fr') ? "Source de l‚Äôillustration" : "Image source";
      creditHTML =
        '<p class="news-credit">'
        + '<a href="'+it.credit_link+'" target="_blank" rel="noopener">'+creditLabel+'</a>'
        + '</p>';
    }

    var isMaintenance = (it.mod === 'maintenance') || (it.type === 'maintenance') || /maintenance/i.test(title);

    var btnHTML = '';

    function ctaBtnClass(url){
      url = String(url || '').toLowerCase();
      if (url.includes('curseforge.com')) return 'card-btn curseforge news-open';
      if (url.includes('modrinth.com'))   return 'card-btn modrinth news-open';
      return 'card-btn wiki news-open';
    }

    if (isAnnouncement && it.cta_link) {
      var ctaLabel = (lang === 'fr'
        ? (it.cta_label_fr || it.cta_label_en || 'Lien')
        : (it.cta_label_en || it.cta_label_fr || 'Link')
      );
      btnHTML =
        '<a href="'+it.cta_link+'" target="_blank" rel="noopener" class="'+ctaBtnClass(it.cta_link)+'">'+ctaLabel+'</a>';
    } else if (!isMaintenance && !isUrgent && it.link) {
      var moreLbl = (lang === 'fr' ? 'En savoir plus' : 'Learn more');
      btnHTML =
        '<a href="'+it.link+'" class="card-btn wiki news-open">'+moreLbl+'</a>';
    }

    return ''
      + (badge || meta ? '<div>'+badge+(meta ? ' <span style="opacity:.85">'+meta+'</span>' : '')+'</div>' : '')
      + (title ? '<div class="title">'+iconAnnouncement+' '+title+'</div>' : '')
      + '<div class="detail-body'+(hasImg?' has-visual':'')+'">'
      +    (hasImg ? visual : '')
      +    '<div class="body-col"'+(isMaintenance?' data-maint="1"':'')+'>'
      +       (summaryToShow ? '<div class="summary">'+summaryToShow+'</div>' : '')
      +       featsHTML
      +       creditHTML
      +       (btnHTML ? '<div class="actions">'+btnHTML+'</div>' : '')
      +    '</div>'
      + '</div>';
  }

  function renderDots(root){
    var dots=root.querySelector('.news-dots'); if(!dots)return;
    var html=''; for(var i=0;i<STATE.items.length;i++){ html+='<button class="dot'+(i===STATE.idx?' active':'')+'" data-idx="'+i+'" aria-label="Slide '+(i+1)+'"></button>'; }
    dots.innerHTML=html;
  }

  function renderDetail(root){
    var lang=localStorage.getItem('siteLanguage')||ETAT?.langue||'fr';
    var it=STATE.items[STATE.idx];
    var box=root.querySelector('.news-detail'); if(!box)return;
    box.innerHTML=it?buildDetailHTML(it,lang):'';
    box.classList.remove('fade-in'); void box.offsetWidth; box.classList.add('fade-in');
  }

  function goTo(root, idx){
    if(!STATE.items.length) return;
    STATE.idx = (idx + STATE.items.length) % STATE.items.length;
    renderDetail(root);
    renderDots(root);
  }

  function startAutoplay(root){
    stopAutoplay();
    if(STATE.items.length<=1) return;
    STATE.timer = setInterval(function(){ goTo(root, STATE.idx+1); }, AUTOPLAY_MS);
  }
  function stopAutoplay(){ if(STATE.timer){ clearInterval(STATE.timer); STATE.timer=null; } }

  async function init() {
    const root = document.getElementById('home-featured');
    if (!root) return;

    // squelette
    root.innerHTML = `
      <div class="news-head">
        <h3 class="news-title"></h3>
        <div class="news-dots" aria-label="Pagination"></div>
      </div>
      <div class="news-viewport">
        <button class="news-nav prev" aria-label="Prev">‚Äπ</button>
        <div class="news-detail"></div>
        <button class="news-nav next" aria-label="Next">‚Ä∫</button>
      </div>
    `;
    root.style.display = '';

    // i18n hook pour ton setLanguage()
    window.__refreshNewsLang = function(){
      var lang = ETAT?.langue || localStorage.getItem('siteLanguage') || 'fr';
      var h = root.querySelector('.news-title');
      if (h) h.textContent = (translations?.[lang]?.news_title) || (lang==='en' ? "What's new" : 'Nouveaut√©s');
      root.querySelector('.news-nav.prev')?.setAttribute('aria-label', lang==='fr'?'Pr√©c√©dent':'Previous');
      root.querySelector('.news-nav.next')?.setAttribute('aria-label', lang==='fr'?'Suivant':'Next');
      renderDetail(root); renderDots(root);
    };

    try { await loadAll(); } catch(e){ console.warn(e); }

    window.__refreshNewsLang();

    if (!STATE.items.length) {
      var lang = ETAT?.langue || 'fr';
      root.querySelector('.news-detail').innerHTML =
        `<div class="summary" style="opacity:.9">${lang==='fr'?'Aucune nouveaut√© pour le moment.':'No news for now.'}</div>`;
      renderDots(root);
      return;
    }

    goTo(root, 0);
    startAutoplay(root);

    // interactions
    root.addEventListener('click', function(e){
      var dot  = e.target.closest && e.target.closest('.dot');
      var prev = e.target.closest && e.target.closest('.news-nav.prev');
      var next = e.target.closest && e.target.closest('.news-nav.next');
      if (dot){ e.preventDefault(); stopAutoplay(); goTo(root, +dot.dataset.idx||0); startAutoplay(root); }
      if (prev){ e.preventDefault(); stopAutoplay(); goTo(root, STATE.idx-1); startAutoplay(root); }
      if (next){ e.preventDefault(); stopAutoplay(); goTo(root, STATE.idx+1); startAutoplay(root); }
    });
    root.addEventListener('mouseenter', function(){ stopAutoplay(); });
    root.addEventListener('mouseleave', function(){ startAutoplay(root); });
  }

  document.addEventListener('DOMContentLoaded', init);
})();
